{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/workbox-precaching/_version.js","webpack:///./node_modules/workbox-core/_version.js","webpack:///./node_modules/workbox-routing/_version.js","webpack:///./node_modules/workbox-strategies/_version.js","webpack:///./node_modules/workbox-expiration/_version.js","webpack:///./node_modules/lodash/_Symbol.js","webpack:///./node_modules/intl-messageformat/lib/utils.js","webpack:///./node_modules/lodash/unescape.js","webpack:///./node_modules/intl-messageformat/index.js","webpack:///./app/javascript/mastodon/service_worker/web_push_locales.js","webpack:///./node_modules/lodash/toString.js","webpack:///./node_modules/lodash/_baseToString.js","webpack:///./node_modules/lodash/_root.js","webpack:///./node_modules/lodash/_freeGlobal.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/lodash/_arrayMap.js","webpack:///./node_modules/lodash/isArray.js","webpack:///./node_modules/lodash/isSymbol.js","webpack:///./node_modules/lodash/_baseGetTag.js","webpack:///./node_modules/lodash/_getRawTag.js","webpack:///./node_modules/lodash/_objectToString.js","webpack:///./node_modules/lodash/isObjectLike.js","webpack:///./node_modules/lodash/_unescapeHtmlChar.js","webpack:///./node_modules/lodash/_basePropertyOf.js","webpack:///./node_modules/intl-messageformat/lib/main.js","webpack:///./node_modules/intl-messageformat/lib/core.js","webpack:///./node_modules/intl-messageformat/lib/es5.js","webpack:///./node_modules/intl-messageformat/lib/compiler.js","webpack:///./node_modules/intl-messageformat-parser/index.js","webpack:///./node_modules/intl-messageformat-parser/lib/parser.js","webpack:///./node_modules/intl-messageformat/lib/en.js","webpack:///./node_modules/workbox-core/models/messages/messages.js","webpack:///./node_modules/workbox-core/models/messages/messageGenerator.js","webpack:///./node_modules/workbox-core/_private/WorkboxError.js","webpack:///./node_modules/workbox-core/_private/dontWaitFor.js","webpack:///./node_modules/idb/build/wrap-idb-value.js","webpack:///./node_modules/idb/build/index.js","webpack:///./node_modules/workbox-expiration/models/CacheTimestampsModel.js","webpack:///./node_modules/workbox-expiration/CacheExpiration.js","webpack:///./node_modules/workbox-core/_private/cacheNames.js","webpack:///./node_modules/workbox-core/_private/getFriendlyURL.js","webpack:///./node_modules/workbox-core/models/quotaErrorCallbacks.js","webpack:///./node_modules/workbox-expiration/ExpirationPlugin.js","webpack:///./node_modules/workbox-core/registerQuotaErrorCallback.js","webpack:///./node_modules/workbox-core/_private/waitUntil.js","webpack:///./node_modules/workbox-precaching/utils/createCacheKey.js","webpack:///./node_modules/workbox-precaching/utils/PrecacheInstallReportPlugin.js","webpack:///./node_modules/workbox-precaching/utils/PrecacheCacheKeyPlugin.js","webpack:///./node_modules/workbox-core/_private/canConstructResponseFromBodyStream.js","webpack:///./node_modules/workbox-core/copyResponse.js","webpack:///./node_modules/workbox-core/_private/cacheMatchIgnoreParams.js","webpack:///./node_modules/workbox-core/_private/Deferred.js","webpack:///./node_modules/workbox-core/_private/timeout.js","webpack:///./node_modules/workbox-strategies/StrategyHandler.js","webpack:///./node_modules/workbox-core/_private/executeQuotaErrorCallbacks.js","webpack:///./node_modules/workbox-strategies/Strategy.js","webpack:///./node_modules/workbox-precaching/PrecacheStrategy.js","webpack:///./node_modules/workbox-precaching/PrecacheController.js","webpack:///./node_modules/workbox-precaching/utils/getOrCreatePrecacheController.js","webpack:///./node_modules/workbox-routing/utils/constants.js","webpack:///./node_modules/workbox-routing/utils/normalizeHandler.js","webpack:///./node_modules/workbox-routing/Route.js","webpack:///./node_modules/workbox-routing/RegExpRoute.js","webpack:///./node_modules/workbox-routing/Router.js","webpack:///./node_modules/workbox-routing/utils/getOrCreateDefaultRouter.js","webpack:///./node_modules/workbox-routing/registerRoute.js","webpack:///./node_modules/workbox-precaching/PrecacheRoute.js","webpack:///./node_modules/workbox-precaching/utils/generateURLVariations.js","webpack:///./node_modules/workbox-precaching/utils/removeIgnoredSearchParams.js","webpack:///./node_modules/workbox-strategies/CacheFirst.js","webpack:///./app/javascript/mastodon/service_worker/web_push_notifications.js","webpack:///./app/javascript/mastodon/service_worker/entry.js","webpack:///./node_modules/workbox-precaching/precacheAndRoute.js","webpack:///./node_modules/workbox-precaching/precache.js","webpack:///./node_modules/workbox-precaching/addRoute.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","self","_","e","extend","obj","len","source","sources","Array","slice","arguments","length","hop","toString","unescapeHtmlChar","reEscapedHtml","reHasEscapedHtml","RegExp","string","test","replace","IntlMessageFormat","baseToString","arrayMap","isArray","isSymbol","symbolProto","undefined","symbolToString","result","freeGlobal","freeSelf","root","Function","global","g","this","window","array","iteratee","index","baseGetTag","isObjectLike","getRawTag","objectToString","symToStringTag","objectProto","nativeObjectToString","isOwn","tag","unmasked","basePropertyOf","src$core$$","src$en$$","__addLocaleData","defaultLocale","src$utils$$","src$es5$$","src$compiler$$","intl$messageformat$parser$$","MessageFormat","message","locales","formats","ast","__parse","type","TypeError","_mergeFormats","_resolveLocale","pluralFn","_findPluralRuleFunction","_locale","pattern","_compilePattern","messageFormat","format","values","_format","variableId","Error","number","style","date","month","day","year","weekday","time","hour","minute","second","timeZoneName","objCreate","data","locale","__localeData__","toLowerCase","parse","writable","resolvedOptions","compile","localeData","pluralRuleFunction","parentLocale","part","id","err","options","getOption","defaults","mergedType","mergedFormats","concat","localeParts","split","join","pop","realDefineProp","__defineGetter__","desc","proto","props","k","F","Compiler","StringFormat","PluralFormat","useOrdinal","offset","PluralOffsetString","numberFormat","SelectFormat","pluralStack","currentPlural","pluralNumberFormat","compileMessage","element","elements","push","compileMessageText","compileArgument","Intl","NumberFormat","DateTimeFormat","compileOptions","ordinal","option","optionsHash","selector","String","other","peg$SyntaxError","expected","found","location","captureStackTrace","child","parent","ctor","constructor","peg$subclass","SyntaxError","input","peg$result","peg$FAILED","peg$startRuleFunctions","start","peg$parsestart","peg$startRuleFunction","peg$c0","peg$c1","text","j","outerLen","inner","innerLen","peg$c2","messageText","peg$c3","peg$c4","description","peg$c5","peg$c6","peg$c7","peg$c8","peg$c9","peg$c10","peg$c11","peg$c12","peg$c13","peg$c14","peg$c15","peg$c16","peg$c17","peg$c18","peg$c19","peg$c20","peg$c21","pluralStyle","peg$c22","peg$c23","peg$c24","peg$c25","peg$c26","peg$c27","peg$c28","peg$c29","peg$c30","peg$c31","peg$c32","peg$c33","peg$c34","peg$c35","peg$c36","peg$c37","peg$c38","peg$c39","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$c46","peg$c47","digits","parseInt","peg$c48","peg$c49","peg$c50","peg$c51","peg$c52","peg$c53","peg$c54","peg$c55","peg$c56","peg$c57","peg$c58","peg$c59","peg$c60","peg$c61","peg$c62","peg$c63","peg$c64","fromCharCode","peg$c65","chars","peg$currPos","peg$savedPos","peg$posDetailsCache","line","column","seenCR","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","startRule","peg$computeLocation","peg$computePosDetails","pos","ch","details","charAt","startPos","endPos","startPosDetails","endPosDetails","end","peg$fail","peg$buildException","sort","a","b","splice","cleanupExpected","expectedDescs","hex","charCodeAt","toUpperCase","stringEscape","buildMessage","peg$parsemessageFormatPattern","s0","s1","s2","peg$parsemessageFormatElement","peg$parsemessageTextElement","peg$parseargumentElement","peg$parsemessageText","s3","s4","s5","peg$parse_","peg$parsechars","peg$parsews","substring","peg$parseargument","peg$parsenumber","s6","s7","s8","peg$parseelementFormat","peg$parsesimpleFormat","peg$parsepluralFormat","peg$parseselectOrdinalFormat","peg$parseselectFormat","substr","peg$parsepluralStyle","peg$parseoptionalFormatPattern","peg$parseselector","peg$parseoffset","peg$parsedigit","peg$parsehexDigit","peg$parsechar","ord","v0","t0","Number","n10","n100","messageGenerator","code","msg","_len","args","_key","JSON","stringify","errorCode","super","dontWaitFor","promise","then","idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","target","prop","receiver","IDBTransaction","objectStoreNames","objectStore","wrap","set","has","wrapFunction","func","IDBDatabase","transaction","IDBCursor","advance","continue","continuePrimaryKey","includes","_len2","_key2","apply","unwrap","_len3","_key3","storeNames","tx","transformCachableValue","done","Promise","resolve","reject","unlisten","removeEventListener","complete","error","DOMException","addEventListener","cacheDonePromiseForTransaction","IDBObjectStore","IDBIndex","some","Proxy","IDBRequest","request","success","catch","promisifyRequest","newValue","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","useIndex","isWrite","method","async","storeName","store","shift","all","oldTraps","callback","CACHE_OBJECT_STORE","normalizeURL","unNormalizedUrl","url","URL","href","hash","cacheName","_db","_cacheName","_upgradeDb","db","objStore","createObjectStore","keyPath","createIndex","unique","_upgradeDbAndDeleteOldDbs","_temp2","blocked","indexedDB","deleteDatabase","deleteDB","timestamp","entry","_getId","getDb","durability","put","minTimestamp","maxCount","cursor","openCursor","entriesToDelete","entriesNotDeletedCount","urlsDeleted","delete","version","_temp","upgrade","blocking","terminated","open","openPromise","event","oldVersion","newVersion","openDB","config","_isRunning","_rerunRequested","_maxEntries","maxEntries","_maxAgeSeconds","maxAgeSeconds","_matchOptions","matchOptions","_timestampModel","Date","now","urlsExpired","expireEntries","cache","caches","setTimestamp","getTimestamp","expireOlderThan","Infinity","_cacheNameDetails","googleAnalytics","precache","prefix","runtime","suffix","registration","scope","_createCacheName","filter","cacheNames","userCacheName","getFriendlyURL","origin","quotaErrorCallbacks","Set","cachedResponseWillBeUsed","cachedResponse","_ref","isFresh","_isResponseDateFresh","cacheExpiration","_getCacheExpiration","updateTimestampDone","updateTimestamp","waitUntil","cacheDidUpdate","_ref2","_config","_cacheExpirations","purgeOnQuotaError","add","registerQuotaErrorCallback","deleteCacheAndMetadata","dateHeaderTimestamp","_getDateHeaderTimestamp","headers","dateHeader","headerTime","getTime","isNaN","asyncFn","returnPromise","createCacheKey","urlObject","cacheKey","revision","cacheKeyURL","originalURL","searchParams","PrecacheInstallReportPlugin","updatedURLs","notUpdatedURLs","handlerWillStart","state","originalRequest","Request","PrecacheCacheKeyPlugin","precacheController","cacheKeyWillBeUsed","params","_precacheController","getCacheKeyForURL","supportStatus","copyResponse","response","modifier","clonedResponse","clone","responseInit","Headers","status","statusText","modifiedResponseInit","body","testResponse","Response","canConstructResponseFromBodyStream","blob","stripParams","fullURL","ignoreParams","strippedURL","param","Deferred","timeout","ms","setTimeout","toRequest","strategy","_cacheKeys","assign","_strategy","_handlerDeferred","_extendLifetimePromises","_plugins","plugins","_pluginStateMap","plugin","FetchEvent","preloadResponse","possiblePreloadResponse","hasCallback","cb","iterateCallbacks","thrownErrorMessage","pluginFilteredRequest","fetchResponse","fetch","fetchOptions","runCallbacks","responseClone","cachePut","effectiveRequest","getCacheKey","multiMatchOptions","match","responseToCache","_ensureResponseSafeToCache","hasCacheUpdateCallback","oldResponse","strippedRequestURL","keysOptions","ignoreSearch","cacheKeys","keys","cacheMatchIgnoreParams","executeQuotaErrorCallbacks","newResponse","statefulCallback","statefulParam","destroy","pluginsUsed","handle","responseDone","handleAll","handler","_getResponse","_awaitComplete","_handle","doneWaiting","waitUntilError","_fallbackToNetwork","fallbackToNetwork","copyRedirectedCacheableResponsesPlugin","cacheMatch","_handleInstall","_handleFetch","integrityInManifest","integrity","integrityInRequest","noIntegrityConflict","_useDefaultCacheabilityPluginIfNeeded","defaultPluginIndex","cacheWillUpdatePluginCount","entries","defaultPrecacheCacheabilityPlugin","cacheWillUpdate","redirected","_urlsToCacheKeys","_urlsToCacheModes","_cacheKeysToIntegrities","install","activate","addToCacheList","_installAndActiveListenersAdded","urlsToWarnAbout","cacheMode","firstEntry","secondEntry","warningMessage","console","warn","installReportPlugin","credentials","currentlyCachedRequests","expectedCacheKeys","deletedURLs","getURLsToCacheKeys","getCachedURLs","getIntegrityForCacheKey","createHandlerBoundToURL","getOrCreatePrecacheController","normalizeHandler","setCatchHandler","catchHandler","regExp","exec","_routes","_defaultHandlerMap","routes","addFetchListener","responsePromise","handleRequest","respondWith","addCacheListener","payload","requestPromises","urlsToCache","map","ports","postMessage","protocol","startsWith","sameOrigin","route","findMatchingRoute","_catchHandler","catchErr","matchResult","setDefaultHandler","registerRoute","unregisterRoute","routeIndex","indexOf","getOrCreateDefaultRouter","capture","captureUrl","moduleName","funcName","paramName","urlsToCacheKeys","possibleURL","ignoreURLParametersMatching","directoryIndex","cleanURLs","urlManipulation","urlWithoutIgnoredParams","removeIgnoredSearchParams","pathname","endsWith","directoryURL","cleanURL","additionalURLs","urlToAttempt","generateURLVariations","fetchAndCachePut","notify","getNotifications","notifications","group","title","formatMessage","preferred_locale","count","n1","n2","notification","badge","icon","forEach","close","showNotification","cloneNotification","fetchFromApi","path","accessToken","res","ok","json","messageId","htmlToPlainText","html","actionExpand","action","actionReblog","actionFavourite","removeActionFromNotification","newNotification","actions","item","openWebCache","__WB_MANIFEST","addRoute","CacheFirst","ExpirationPlugin","destination","redirect","clients","claim","asyncResponse","asyncCache","access_token","notification_id","account","display_name","username","content","avatar_static","created_at","image","media_attachments","preview_url","acct","spoiler_text","sensitive","hiddenBody","hiddenImage","reactToNotificationClick","expandNotification","matchAll","clientList","focusedClient","find","client","focused","visibleClient","visibilityState","findBestClient","navigate","focus","openWindow"],"mappings":"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","file":"sw.js","sourceRoot":"","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/packs/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 32);\n","\"use strict\";\n\n// @ts-ignore\ntry {\n  self['workbox:precaching:6.5.3'] && _();\n} catch (e) {}","\"use strict\";\n\n// @ts-ignore\ntry {\n  self['workbox:core:6.5.3'] && _();\n} catch (e) {}","\"use strict\";\n\n// @ts-ignore\ntry {\n  self['workbox:routing:6.5.3'] && _();\n} catch (e) {}","\"use strict\";\n\n// @ts-ignore\ntry {\n  self['workbox:strategies:6.5.3'] && _();\n} catch (e) {}","\"use strict\";\n\n// @ts-ignore\ntry {\n  self['workbox:expiration:6.5.3'] && _();\n} catch (e) {}","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\nmodule.exports = Symbol;","/*\nCopyright (c) 2014, Yahoo! Inc. All rights reserved.\nCopyrights licensed under the New BSD License.\nSee the accompanying LICENSE file for terms.\n*/\n\n/* jslint esnext: true */\n\n\"use strict\";\n\nexports.extend = extend;\nvar hop = Object.prototype.hasOwnProperty;\nfunction extend(obj) {\n  var sources = Array.prototype.slice.call(arguments, 1),\n    i,\n    len,\n    source,\n    key;\n  for (i = 0, len = sources.length; i < len; i += 1) {\n    source = sources[i];\n    if (!source) {\n      continue;\n    }\n    for (key in source) {\n      if (hop.call(source, key)) {\n        obj[key] = source[key];\n      }\n    }\n  }\n  return obj;\n}\nexports.hop = hop;","var toString = require('./toString'),\n  unescapeHtmlChar = require('./_unescapeHtmlChar');\n\n/** Used to match HTML entities and HTML characters. */\nvar reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,\n  reHasEscapedHtml = RegExp(reEscapedHtml.source);\n\n/**\n * The inverse of `_.escape`; this method converts the HTML entities\n * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to\n * their corresponding characters.\n *\n * **Note:** No other HTML entities are unescaped. To unescape additional\n * HTML entities use a third-party library like [_he_](https://mths.be/he).\n *\n * @static\n * @memberOf _\n * @since 0.6.0\n * @category String\n * @param {string} [string=''] The string to unescape.\n * @returns {string} Returns the unescaped string.\n * @example\n *\n * _.unescape('fred, barney, &amp; pebbles');\n * // => 'fred, barney, & pebbles'\n */\nfunction unescape(string) {\n  string = toString(string);\n  return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;\n}\nmodule.exports = unescape;","/* jshint node:true */\n\n'use strict';\n\nvar IntlMessageFormat = require('./lib/main')['default'];\n\n// Add all locale data to `IntlMessageFormat`. This module will be ignored when\n// bundling for the browser with Browserify/Webpack.\nrequire('./lib/locales');\n\n// Re-export `IntlMessageFormat` as the CommonJS default exports with all the\n// locale data registered, and with English set as the default locale. Define\n// the `default` prop for use with other compiled ES6 Modules.\nexports = module.exports = IntlMessageFormat;\nexports['default'] = exports;","/* @preval */\n\nconst fs   = require('fs');\nconst path = require('path');\n\nconst filtered  = {};\nconst filenames = fs.readdirSync(path.resolve(__dirname, '../locales'));\n\nfilenames.forEach(filename => {\n  if (!filename.match(/\\.json$/) || filename.match(/defaultMessages|whitelist/)) return;\n\n  const content = fs.readFileSync(path.resolve(__dirname, `../locales/${filename}`), 'utf-8');\n  const full    = JSON.parse(content);\n  const locale  = filename.split('.')[0];\n\n  filtered[locale] = {\n    'notification.favourite': full['notification.favourite'] || '',\n    'notification.follow': full['notification.follow'] || '',\n    'notification.follow_request': full['notification.follow_request'] || '',\n    'notification.mention': full['notification.mention'] || '',\n    'notification.reblog': full['notification.reblog'] || '',\n    'notification.poll': full['notification.poll'] || '',\n    'notification.status': full['notification.status'] || '',\n    'notification.update': full['notification.update'] || '',\n    'notification.admin.sign_up': full['notification.admin.sign_up'] || '',\n\n    'status.show_more': full['status.show_more'] || '',\n    'status.reblog': full['status.reblog'] || '',\n    'status.favourite': full['status.favourite'] || '',\n\n    'notifications.group': full['notifications.group'] || '',\n  };\n});\n\nmodule.exports = JSON.parse(JSON.stringify(filtered));\n","var baseToString = require('./_baseToString');\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\nmodule.exports = toString;","var Symbol = require('./_Symbol'),\n  arrayMap = require('./_arrayMap'),\n  isArray = require('./isArray'),\n  isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n  symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = value + '';\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n}\nmodule.exports = baseToString;","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\nmodule.exports = root;","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\nmodule.exports = freeGlobal;","var g;\n\n// This works in non-strict mode\ng = function () {\n  return this;\n}();\ntry {\n  // This works if eval is allowed (see CSP)\n  g = g || new Function(\"return this\")();\n} catch (e) {\n  // This works if the window reference is available\n  if (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n    length = array == null ? 0 : array.length,\n    result = Array(length);\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\nmodule.exports = arrayMap;","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\nmodule.exports = isArray;","var baseGetTag = require('./_baseGetTag'),\n  isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;\n}\nmodule.exports = isSymbol;","var Symbol = require('./_Symbol'),\n  getRawTag = require('./_getRawTag'),\n  objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n  undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n}\nmodule.exports = baseGetTag;","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n    tag = value[symToStringTag];\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\nmodule.exports = getRawTag;","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\nmodule.exports = objectToString;","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\nmodule.exports = isObjectLike;","var basePropertyOf = require('./_basePropertyOf');\n\n/** Used to map HTML entities to characters. */\nvar htmlUnescapes = {\n  '&amp;': '&',\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&#39;': \"'\"\n};\n\n/**\n * Used by `_.unescape` to convert HTML entities to characters.\n *\n * @private\n * @param {string} chr The matched character to unescape.\n * @returns {string} Returns the unescaped character.\n */\nvar unescapeHtmlChar = basePropertyOf(htmlUnescapes);\nmodule.exports = unescapeHtmlChar;","/**\n * The base implementation of `_.propertyOf` without support for deep paths.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyOf(object) {\n  return function (key) {\n    return object == null ? undefined : object[key];\n  };\n}\nmodule.exports = basePropertyOf;","/* jslint esnext: true */\n\n\"use strict\";\n\nvar src$core$$ = require(\"./core\"),\n  src$en$$ = require(\"./en\");\nsrc$core$$[\"default\"].__addLocaleData(src$en$$[\"default\"]);\nsrc$core$$[\"default\"].defaultLocale = 'en';\nexports[\"default\"] = src$core$$[\"default\"];","/*\nCopyright (c) 2014, Yahoo! Inc. All rights reserved.\nCopyrights licensed under the New BSD License.\nSee the accompanying LICENSE file for terms.\n*/\n\n/* jslint esnext: true */\n\n\"use strict\";\n\nvar src$utils$$ = require(\"./utils\"),\n  src$es5$$ = require(\"./es5\"),\n  src$compiler$$ = require(\"./compiler\"),\n  intl$messageformat$parser$$ = require(\"intl-messageformat-parser\");\nexports[\"default\"] = MessageFormat;\n\n// -- MessageFormat --------------------------------------------------------\n\nfunction MessageFormat(message, locales, formats) {\n  // Parse string messages into an AST.\n  var ast = typeof message === 'string' ? MessageFormat.__parse(message) : message;\n  if (!(ast && ast.type === 'messageFormatPattern')) {\n    throw new TypeError('A message must be provided as a String or AST.');\n  }\n\n  // Creates a new object with the specified `formats` merged with the default\n  // formats.\n  formats = this._mergeFormats(MessageFormat.formats, formats);\n\n  // Defined first because it's used to build the format pattern.\n  src$es5$$.defineProperty(this, '_locale', {\n    value: this._resolveLocale(locales)\n  });\n\n  // Compile the `ast` to a pattern that is highly optimized for repeated\n  // `format()` invocations. **Note:** This passes the `locales` set provided\n  // to the constructor instead of just the resolved locale.\n  var pluralFn = this._findPluralRuleFunction(this._locale);\n  var pattern = this._compilePattern(ast, locales, formats, pluralFn);\n\n  // \"Bind\" `format()` method to `this` so it can be passed by reference like\n  // the other `Intl` APIs.\n  var messageFormat = this;\n  this.format = function (values) {\n    try {\n      return messageFormat._format(pattern, values);\n    } catch (e) {\n      if (e.variableId) {\n        throw new Error('The intl string context variable \\'' + e.variableId + '\\'' + ' was not provided to the string \\'' + message + '\\'');\n      } else {\n        throw e;\n      }\n    }\n  };\n}\n\n// Default format options used as the prototype of the `formats` provided to the\n// constructor. These are used when constructing the internal Intl.NumberFormat\n// and Intl.DateTimeFormat instances.\nsrc$es5$$.defineProperty(MessageFormat, 'formats', {\n  enumerable: true,\n  value: {\n    number: {\n      'currency': {\n        style: 'currency'\n      },\n      'percent': {\n        style: 'percent'\n      }\n    },\n    date: {\n      'short': {\n        month: 'numeric',\n        day: 'numeric',\n        year: '2-digit'\n      },\n      'medium': {\n        month: 'short',\n        day: 'numeric',\n        year: 'numeric'\n      },\n      'long': {\n        month: 'long',\n        day: 'numeric',\n        year: 'numeric'\n      },\n      'full': {\n        weekday: 'long',\n        month: 'long',\n        day: 'numeric',\n        year: 'numeric'\n      }\n    },\n    time: {\n      'short': {\n        hour: 'numeric',\n        minute: 'numeric'\n      },\n      'medium': {\n        hour: 'numeric',\n        minute: 'numeric',\n        second: 'numeric'\n      },\n      'long': {\n        hour: 'numeric',\n        minute: 'numeric',\n        second: 'numeric',\n        timeZoneName: 'short'\n      },\n      'full': {\n        hour: 'numeric',\n        minute: 'numeric',\n        second: 'numeric',\n        timeZoneName: 'short'\n      }\n    }\n  }\n});\n\n// Define internal private properties for dealing with locale data.\nsrc$es5$$.defineProperty(MessageFormat, '__localeData__', {\n  value: src$es5$$.objCreate(null)\n});\nsrc$es5$$.defineProperty(MessageFormat, '__addLocaleData', {\n  value: function (data) {\n    if (!(data && data.locale)) {\n      throw new Error('Locale data provided to IntlMessageFormat is missing a ' + '`locale` property');\n    }\n    MessageFormat.__localeData__[data.locale.toLowerCase()] = data;\n  }\n});\n\n// Defines `__parse()` static method as an exposed private.\nsrc$es5$$.defineProperty(MessageFormat, '__parse', {\n  value: intl$messageformat$parser$$[\"default\"].parse\n});\n\n// Define public `defaultLocale` property which defaults to English, but can be\n// set by the developer.\nsrc$es5$$.defineProperty(MessageFormat, 'defaultLocale', {\n  enumerable: true,\n  writable: true,\n  value: undefined\n});\nMessageFormat.prototype.resolvedOptions = function () {\n  // TODO: Provide anything else?\n  return {\n    locale: this._locale\n  };\n};\nMessageFormat.prototype._compilePattern = function (ast, locales, formats, pluralFn) {\n  var compiler = new src$compiler$$[\"default\"](locales, formats, pluralFn);\n  return compiler.compile(ast);\n};\nMessageFormat.prototype._findPluralRuleFunction = function (locale) {\n  var localeData = MessageFormat.__localeData__;\n  var data = localeData[locale.toLowerCase()];\n\n  // The locale data is de-duplicated, so we have to traverse the locale's\n  // hierarchy until we find a `pluralRuleFunction` to return.\n  while (data) {\n    if (data.pluralRuleFunction) {\n      return data.pluralRuleFunction;\n    }\n    data = data.parentLocale && localeData[data.parentLocale.toLowerCase()];\n  }\n  throw new Error('Locale data added to IntlMessageFormat is missing a ' + '`pluralRuleFunction` for :' + locale);\n};\nMessageFormat.prototype._format = function (pattern, values) {\n  var result = '',\n    i,\n    len,\n    part,\n    id,\n    value,\n    err;\n  for (i = 0, len = pattern.length; i < len; i += 1) {\n    part = pattern[i];\n\n    // Exist early for string parts.\n    if (typeof part === 'string') {\n      result += part;\n      continue;\n    }\n    id = part.id;\n\n    // Enforce that all required values are provided by the caller.\n    if (!(values && src$utils$$.hop.call(values, id))) {\n      err = new Error('A value must be provided for: ' + id);\n      err.variableId = id;\n      throw err;\n    }\n    value = values[id];\n\n    // Recursively format plural and select parts' option — which can be a\n    // nested pattern structure. The choosing of the option to use is\n    // abstracted-by and delegated-to the part helper object.\n    if (part.options) {\n      result += this._format(part.getOption(value), values);\n    } else {\n      result += part.format(value);\n    }\n  }\n  return result;\n};\nMessageFormat.prototype._mergeFormats = function (defaults, formats) {\n  var mergedFormats = {},\n    type,\n    mergedType;\n  for (type in defaults) {\n    if (!src$utils$$.hop.call(defaults, type)) {\n      continue;\n    }\n    mergedFormats[type] = mergedType = src$es5$$.objCreate(defaults[type]);\n    if (formats && src$utils$$.hop.call(formats, type)) {\n      src$utils$$.extend(mergedType, formats[type]);\n    }\n  }\n  return mergedFormats;\n};\nMessageFormat.prototype._resolveLocale = function (locales) {\n  if (typeof locales === 'string') {\n    locales = [locales];\n  }\n\n  // Create a copy of the array so we can push on the default locale.\n  locales = (locales || []).concat(MessageFormat.defaultLocale);\n  var localeData = MessageFormat.__localeData__;\n  var i, len, localeParts, data;\n\n  // Using the set of locales + the default locale, we look for the first one\n  // which that has been registered. When data does not exist for a locale, we\n  // traverse its ancestors to find something that's been registered within\n  // its hierarchy of locales. Since we lack the proper `parentLocale` data\n  // here, we must take a naive approach to traversal.\n  for (i = 0, len = locales.length; i < len; i += 1) {\n    localeParts = locales[i].toLowerCase().split('-');\n    while (localeParts.length) {\n      data = localeData[localeParts.join('-')];\n      if (data) {\n        // Return the normalized locale string; e.g., we return \"en-US\",\n        // instead of \"en-us\".\n        return data.locale;\n      }\n      localeParts.pop();\n    }\n  }\n  var defaultLocale = locales.pop();\n  throw new Error('No locale data has been added to IntlMessageFormat for: ' + locales.join(', ') + ', or the default locale: ' + defaultLocale);\n};","/*\nCopyright (c) 2014, Yahoo! Inc. All rights reserved.\nCopyrights licensed under the New BSD License.\nSee the accompanying LICENSE file for terms.\n*/\n\n/* jslint esnext: true */\n\n\"use strict\";\n\nvar src$utils$$ = require(\"./utils\");\n\n// Purposely using the same implementation as the Intl.js `Intl` polyfill.\n// Copyright 2013 Andy Earnshaw, MIT License\n\nvar realDefineProp = function () {\n  try {\n    return !!Object.defineProperty({}, 'a', {});\n  } catch (e) {\n    return false;\n  }\n}();\nvar es3 = !realDefineProp && !Object.prototype.__defineGetter__;\nvar defineProperty = realDefineProp ? Object.defineProperty : function (obj, name, desc) {\n  if ('get' in desc && obj.__defineGetter__) {\n    obj.__defineGetter__(name, desc.get);\n  } else if (!src$utils$$.hop.call(obj, name) || 'value' in desc) {\n    obj[name] = desc.value;\n  }\n};\nvar objCreate = Object.create || function (proto, props) {\n  var obj, k;\n  function F() {}\n  F.prototype = proto;\n  obj = new F();\n  for (k in props) {\n    if (src$utils$$.hop.call(props, k)) {\n      defineProperty(obj, k, props[k]);\n    }\n  }\n  return obj;\n};\nexports.defineProperty = defineProperty, exports.objCreate = objCreate;","/*\nCopyright (c) 2014, Yahoo! Inc. All rights reserved.\nCopyrights licensed under the New BSD License.\nSee the accompanying LICENSE file for terms.\n*/\n\n/* jslint esnext: true */\n\n\"use strict\";\n\nexports[\"default\"] = Compiler;\nfunction Compiler(locales, formats, pluralFn) {\n  this.locales = locales;\n  this.formats = formats;\n  this.pluralFn = pluralFn;\n}\nCompiler.prototype.compile = function (ast) {\n  this.pluralStack = [];\n  this.currentPlural = null;\n  this.pluralNumberFormat = null;\n  return this.compileMessage(ast);\n};\nCompiler.prototype.compileMessage = function (ast) {\n  if (!(ast && ast.type === 'messageFormatPattern')) {\n    throw new Error('Message AST is not of type: \"messageFormatPattern\"');\n  }\n  var elements = ast.elements,\n    pattern = [];\n  var i, len, element;\n  for (i = 0, len = elements.length; i < len; i += 1) {\n    element = elements[i];\n    switch (element.type) {\n      case 'messageTextElement':\n        pattern.push(this.compileMessageText(element));\n        break;\n      case 'argumentElement':\n        pattern.push(this.compileArgument(element));\n        break;\n      default:\n        throw new Error('Message element does not have a valid type');\n    }\n  }\n  return pattern;\n};\nCompiler.prototype.compileMessageText = function (element) {\n  // When this `element` is part of plural sub-pattern and its value contains\n  // an unescaped '#', use a `PluralOffsetString` helper to properly output\n  // the number with the correct offset in the string.\n  if (this.currentPlural && /(^|[^\\\\])#/g.test(element.value)) {\n    // Create a cache a NumberFormat instance that can be reused for any\n    // PluralOffsetString instance in this message.\n    if (!this.pluralNumberFormat) {\n      this.pluralNumberFormat = new Intl.NumberFormat(this.locales);\n    }\n    return new PluralOffsetString(this.currentPlural.id, this.currentPlural.format.offset, this.pluralNumberFormat, element.value);\n  }\n\n  // Unescape the escaped '#'s in the message text.\n  return element.value.replace(/\\\\#/g, '#');\n};\nCompiler.prototype.compileArgument = function (element) {\n  var format = element.format;\n  if (!format) {\n    return new StringFormat(element.id);\n  }\n  var formats = this.formats,\n    locales = this.locales,\n    pluralFn = this.pluralFn,\n    options;\n  switch (format.type) {\n    case 'numberFormat':\n      options = formats.number[format.style];\n      return {\n        id: element.id,\n        format: new Intl.NumberFormat(locales, options).format\n      };\n    case 'dateFormat':\n      options = formats.date[format.style];\n      return {\n        id: element.id,\n        format: new Intl.DateTimeFormat(locales, options).format\n      };\n    case 'timeFormat':\n      options = formats.time[format.style];\n      return {\n        id: element.id,\n        format: new Intl.DateTimeFormat(locales, options).format\n      };\n    case 'pluralFormat':\n      options = this.compileOptions(element);\n      return new PluralFormat(element.id, format.ordinal, format.offset, options, pluralFn);\n    case 'selectFormat':\n      options = this.compileOptions(element);\n      return new SelectFormat(element.id, options);\n    default:\n      throw new Error('Message element does not have a valid format type');\n  }\n};\nCompiler.prototype.compileOptions = function (element) {\n  var format = element.format,\n    options = format.options,\n    optionsHash = {};\n\n  // Save the current plural element, if any, then set it to a new value when\n  // compiling the options sub-patterns. This conforms the spec's algorithm\n  // for handling `\"#\"` syntax in message text.\n  this.pluralStack.push(this.currentPlural);\n  this.currentPlural = format.type === 'pluralFormat' ? element : null;\n  var i, len, option;\n  for (i = 0, len = options.length; i < len; i += 1) {\n    option = options[i];\n\n    // Compile the sub-pattern and save it under the options's selector.\n    optionsHash[option.selector] = this.compileMessage(option.value);\n  }\n\n  // Pop the plural stack to put back the original current plural value.\n  this.currentPlural = this.pluralStack.pop();\n  return optionsHash;\n};\n\n// -- Compiler Helper Classes --------------------------------------------------\n\nfunction StringFormat(id) {\n  this.id = id;\n}\nStringFormat.prototype.format = function (value) {\n  if (!value && typeof value !== 'number') {\n    return '';\n  }\n  return typeof value === 'string' ? value : String(value);\n};\nfunction PluralFormat(id, useOrdinal, offset, options, pluralFn) {\n  this.id = id;\n  this.useOrdinal = useOrdinal;\n  this.offset = offset;\n  this.options = options;\n  this.pluralFn = pluralFn;\n}\nPluralFormat.prototype.getOption = function (value) {\n  var options = this.options;\n  var option = options['=' + value] || options[this.pluralFn(value - this.offset, this.useOrdinal)];\n  return option || options.other;\n};\nfunction PluralOffsetString(id, offset, numberFormat, string) {\n  this.id = id;\n  this.offset = offset;\n  this.numberFormat = numberFormat;\n  this.string = string;\n}\nPluralOffsetString.prototype.format = function (value) {\n  var number = this.numberFormat.format(value - this.offset);\n  return this.string.replace(/(^|[^\\\\])#/g, '$1' + number).replace(/\\\\#/g, '#');\n};\nfunction SelectFormat(id, options) {\n  this.id = id;\n  this.options = options;\n}\nSelectFormat.prototype.getOption = function (value) {\n  var options = this.options;\n  return options[value] || options.other;\n};","'use strict';\n\nexports = module.exports = require('./lib/parser')['default'];\nexports['default'] = exports;","\"use strict\";\n\nexports[\"default\"] = function () {\n  \"use strict\";\n\n  /*\n   * Generated by PEG.js 0.9.0.\n   *\n   * http://pegjs.org/\n   */\n  function peg$subclass(child, parent) {\n    function ctor() {\n      this.constructor = child;\n    }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message = message;\n    this.expected = expected;\n    this.found = found;\n    this.location = location;\n    this.name = \"SyntaxError\";\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n  peg$subclass(peg$SyntaxError, Error);\n  function peg$parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n      parser = this,\n      peg$FAILED = {},\n      peg$startRuleFunctions = {\n        start: peg$parsestart\n      },\n      peg$startRuleFunction = peg$parsestart,\n      peg$c0 = function (elements) {\n        return {\n          type: 'messageFormatPattern',\n          elements: elements,\n          location: location()\n        };\n      },\n      peg$c1 = function (text) {\n        var string = '',\n          i,\n          j,\n          outerLen,\n          inner,\n          innerLen;\n        for (i = 0, outerLen = text.length; i < outerLen; i += 1) {\n          inner = text[i];\n          for (j = 0, innerLen = inner.length; j < innerLen; j += 1) {\n            string += inner[j];\n          }\n        }\n        return string;\n      },\n      peg$c2 = function (messageText) {\n        return {\n          type: 'messageTextElement',\n          value: messageText,\n          location: location()\n        };\n      },\n      peg$c3 = /^[^ \\t\\n\\r,.+={}#]/,\n      peg$c4 = {\n        type: \"class\",\n        value: \"[^ \\\\t\\\\n\\\\r,.+={}#]\",\n        description: \"[^ \\\\t\\\\n\\\\r,.+={}#]\"\n      },\n      peg$c5 = \"{\",\n      peg$c6 = {\n        type: \"literal\",\n        value: \"{\",\n        description: \"\\\"{\\\"\"\n      },\n      peg$c7 = \",\",\n      peg$c8 = {\n        type: \"literal\",\n        value: \",\",\n        description: \"\\\",\\\"\"\n      },\n      peg$c9 = \"}\",\n      peg$c10 = {\n        type: \"literal\",\n        value: \"}\",\n        description: \"\\\"}\\\"\"\n      },\n      peg$c11 = function (id, format) {\n        return {\n          type: 'argumentElement',\n          id: id,\n          format: format && format[2],\n          location: location()\n        };\n      },\n      peg$c12 = \"number\",\n      peg$c13 = {\n        type: \"literal\",\n        value: \"number\",\n        description: \"\\\"number\\\"\"\n      },\n      peg$c14 = \"date\",\n      peg$c15 = {\n        type: \"literal\",\n        value: \"date\",\n        description: \"\\\"date\\\"\"\n      },\n      peg$c16 = \"time\",\n      peg$c17 = {\n        type: \"literal\",\n        value: \"time\",\n        description: \"\\\"time\\\"\"\n      },\n      peg$c18 = function (type, style) {\n        return {\n          type: type + 'Format',\n          style: style && style[2],\n          location: location()\n        };\n      },\n      peg$c19 = \"plural\",\n      peg$c20 = {\n        type: \"literal\",\n        value: \"plural\",\n        description: \"\\\"plural\\\"\"\n      },\n      peg$c21 = function (pluralStyle) {\n        return {\n          type: pluralStyle.type,\n          ordinal: false,\n          offset: pluralStyle.offset || 0,\n          options: pluralStyle.options,\n          location: location()\n        };\n      },\n      peg$c22 = \"selectordinal\",\n      peg$c23 = {\n        type: \"literal\",\n        value: \"selectordinal\",\n        description: \"\\\"selectordinal\\\"\"\n      },\n      peg$c24 = function (pluralStyle) {\n        return {\n          type: pluralStyle.type,\n          ordinal: true,\n          offset: pluralStyle.offset || 0,\n          options: pluralStyle.options,\n          location: location()\n        };\n      },\n      peg$c25 = \"select\",\n      peg$c26 = {\n        type: \"literal\",\n        value: \"select\",\n        description: \"\\\"select\\\"\"\n      },\n      peg$c27 = function (options) {\n        return {\n          type: 'selectFormat',\n          options: options,\n          location: location()\n        };\n      },\n      peg$c28 = \"=\",\n      peg$c29 = {\n        type: \"literal\",\n        value: \"=\",\n        description: \"\\\"=\\\"\"\n      },\n      peg$c30 = function (selector, pattern) {\n        return {\n          type: 'optionalFormatPattern',\n          selector: selector,\n          value: pattern,\n          location: location()\n        };\n      },\n      peg$c31 = \"offset:\",\n      peg$c32 = {\n        type: \"literal\",\n        value: \"offset:\",\n        description: \"\\\"offset:\\\"\"\n      },\n      peg$c33 = function (number) {\n        return number;\n      },\n      peg$c34 = function (offset, options) {\n        return {\n          type: 'pluralFormat',\n          offset: offset,\n          options: options,\n          location: location()\n        };\n      },\n      peg$c35 = {\n        type: \"other\",\n        description: \"whitespace\"\n      },\n      peg$c36 = /^[ \\t\\n\\r]/,\n      peg$c37 = {\n        type: \"class\",\n        value: \"[ \\\\t\\\\n\\\\r]\",\n        description: \"[ \\\\t\\\\n\\\\r]\"\n      },\n      peg$c38 = {\n        type: \"other\",\n        description: \"optionalWhitespace\"\n      },\n      peg$c39 = /^[0-9]/,\n      peg$c40 = {\n        type: \"class\",\n        value: \"[0-9]\",\n        description: \"[0-9]\"\n      },\n      peg$c41 = /^[0-9a-f]/i,\n      peg$c42 = {\n        type: \"class\",\n        value: \"[0-9a-f]i\",\n        description: \"[0-9a-f]i\"\n      },\n      peg$c43 = \"0\",\n      peg$c44 = {\n        type: \"literal\",\n        value: \"0\",\n        description: \"\\\"0\\\"\"\n      },\n      peg$c45 = /^[1-9]/,\n      peg$c46 = {\n        type: \"class\",\n        value: \"[1-9]\",\n        description: \"[1-9]\"\n      },\n      peg$c47 = function (digits) {\n        return parseInt(digits, 10);\n      },\n      peg$c48 = /^[^{}\\\\\\0-\\x1F \\t\\n\\r]/,\n      peg$c49 = {\n        type: \"class\",\n        value: \"[^{}\\\\\\\\\\\\0-\\\\x1F\\\\x7f \\\\t\\\\n\\\\r]\",\n        description: \"[^{}\\\\\\\\\\\\0-\\\\x1F\\\\x7f \\\\t\\\\n\\\\r]\"\n      },\n      peg$c50 = \"\\\\\\\\\",\n      peg$c51 = {\n        type: \"literal\",\n        value: \"\\\\\\\\\",\n        description: \"\\\"\\\\\\\\\\\\\\\\\\\"\"\n      },\n      peg$c52 = function () {\n        return '\\\\';\n      },\n      peg$c53 = \"\\\\#\",\n      peg$c54 = {\n        type: \"literal\",\n        value: \"\\\\#\",\n        description: \"\\\"\\\\\\\\#\\\"\"\n      },\n      peg$c55 = function () {\n        return '\\\\#';\n      },\n      peg$c56 = \"\\\\{\",\n      peg$c57 = {\n        type: \"literal\",\n        value: \"\\\\{\",\n        description: \"\\\"\\\\\\\\{\\\"\"\n      },\n      peg$c58 = function () {\n        return '\\u007B';\n      },\n      peg$c59 = \"\\\\}\",\n      peg$c60 = {\n        type: \"literal\",\n        value: \"\\\\}\",\n        description: \"\\\"\\\\\\\\}\\\"\"\n      },\n      peg$c61 = function () {\n        return '\\u007D';\n      },\n      peg$c62 = \"\\\\u\",\n      peg$c63 = {\n        type: \"literal\",\n        value: \"\\\\u\",\n        description: \"\\\"\\\\\\\\u\\\"\"\n      },\n      peg$c64 = function (digits) {\n        return String.fromCharCode(parseInt(digits, 16));\n      },\n      peg$c65 = function (chars) {\n        return chars.join('');\n      },\n      peg$currPos = 0,\n      peg$savedPos = 0,\n      peg$posDetailsCache = [{\n        line: 1,\n        column: 1,\n        seenCR: false\n      }],\n      peg$maxFailPos = 0,\n      peg$maxFailExpected = [],\n      peg$silentFails = 0,\n      peg$result;\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n    function expected(description) {\n      throw peg$buildException(null, [{\n        type: \"other\",\n        description: description\n      }], input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));\n    }\n    function error(message) {\n      throw peg$buildException(message, null, input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));\n    }\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos],\n        p,\n        ch;\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n        details = peg$posDetailsCache[p];\n        details = {\n          line: details.line,\n          column: details.column,\n          seenCR: details.seenCR\n        };\n        while (p < pos) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) {\n              details.line++;\n            }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n          p++;\n        }\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails = peg$computePosDetails(endPos);\n      return {\n        start: {\n          offset: startPos,\n          line: startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line: endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) {\n        return;\n      }\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n      peg$maxFailExpected.push(expected);\n    }\n    function peg$buildException(message, expected, found, location) {\n      function cleanupExpected(expected) {\n        var i = 1;\n        expected.sort(function (a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) {\n            return ch.charCodeAt(0).toString(16).toUpperCase();\n          }\n          return s.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\x08/g, '\\\\b').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\f/g, '\\\\f').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function (ch) {\n            return '\\\\x0' + hex(ch);\n          }).replace(/[\\x10-\\x1F\\x80-\\xFF]/g, function (ch) {\n            return '\\\\x' + hex(ch);\n          }).replace(/[\\u0100-\\u0FFF]/g, function (ch) {\n            return '\\\\u0' + hex(ch);\n          }).replace(/[\\u1000-\\uFFFF]/g, function (ch) {\n            return '\\\\u' + hex(ch);\n          });\n        }\n        var expectedDescs = new Array(expected.length),\n          expectedDesc,\n          foundDesc,\n          i;\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n        expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(\", \") + \" or \" + expectedDescs[expected.length - 1] : expectedDescs[0];\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n      return new peg$SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, location);\n    }\n    function peg$parsestart() {\n      var s0;\n      s0 = peg$parsemessageFormatPattern();\n      return s0;\n    }\n    function peg$parsemessageFormatPattern() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsemessageFormatElement();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsemessageFormatElement();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c0(s1);\n      }\n      s0 = s1;\n      return s0;\n    }\n    function peg$parsemessageFormatElement() {\n      var s0;\n      s0 = peg$parsemessageTextElement();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseargumentElement();\n      }\n      return s0;\n    }\n    function peg$parsemessageText() {\n      var s0, s1, s2, s3, s4, s5;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = peg$parse_();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsechars();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parse_();\n          if (s5 !== peg$FAILED) {\n            s3 = [s3, s4, s5];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$currPos;\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsechars();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                s3 = [s3, s4, s5];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsews();\n        if (s1 !== peg$FAILED) {\n          s0 = input.substring(s0, peg$currPos);\n        } else {\n          s0 = s1;\n        }\n      }\n      return s0;\n    }\n    function peg$parsemessageTextElement() {\n      var s0, s1;\n      s0 = peg$currPos;\n      s1 = peg$parsemessageText();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c2(s1);\n      }\n      s0 = s1;\n      return s0;\n    }\n    function peg$parseargument() {\n      var s0, s1, s2;\n      s0 = peg$parsenumber();\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = [];\n        if (peg$c3.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c4);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            if (peg$c3.test(input.charAt(peg$currPos))) {\n              s2 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c4);\n              }\n            }\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s0 = input.substring(s0, peg$currPos);\n        } else {\n          s0 = s1;\n        }\n      }\n      return s0;\n    }\n    function peg$parseargumentElement() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 123) {\n        s1 = peg$c5;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c6);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseargument();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s6 = peg$c7;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$c8);\n                }\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parse_();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parseelementFormat();\n                  if (s8 !== peg$FAILED) {\n                    s6 = [s6, s7, s8];\n                    s5 = s6;\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n              if (s5 === peg$FAILED) {\n                s5 = null;\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_();\n                if (s6 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 125) {\n                    s7 = peg$c9;\n                    peg$currPos++;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                      peg$fail(peg$c10);\n                    }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c11(s3, s5);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseelementFormat() {\n      var s0;\n      s0 = peg$parsesimpleFormat();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsepluralFormat();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseselectOrdinalFormat();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseselectFormat();\n          }\n        }\n      }\n      return s0;\n    }\n    function peg$parsesimpleFormat() {\n      var s0, s1, s2, s3, s4, s5, s6;\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 6) === peg$c12) {\n        s1 = peg$c12;\n        peg$currPos += 6;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c13);\n        }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.substr(peg$currPos, 4) === peg$c14) {\n          s1 = peg$c14;\n          peg$currPos += 4;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c15);\n          }\n        }\n        if (s1 === peg$FAILED) {\n          if (input.substr(peg$currPos, 4) === peg$c16) {\n            s1 = peg$c16;\n            peg$currPos += 4;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c17);\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s4 = peg$c7;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c8);\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parse_();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsechars();\n              if (s6 !== peg$FAILED) {\n                s4 = [s4, s5, s6];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c18(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsepluralFormat() {\n      var s0, s1, s2, s3, s4, s5;\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 6) === peg$c19) {\n        s1 = peg$c19;\n        peg$currPos += 6;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c20);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s3 = peg$c7;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c8);\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsepluralStyle();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c21(s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseselectOrdinalFormat() {\n      var s0, s1, s2, s3, s4, s5;\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 13) === peg$c22) {\n        s1 = peg$c22;\n        peg$currPos += 13;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c23);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s3 = peg$c7;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c8);\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsepluralStyle();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c24(s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseselectFormat() {\n      var s0, s1, s2, s3, s4, s5, s6;\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 6) === peg$c25) {\n        s1 = peg$c25;\n        peg$currPos += 6;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c26);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s3 = peg$c7;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c8);\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n              s6 = peg$parseoptionalFormatPattern();\n              if (s6 !== peg$FAILED) {\n                while (s6 !== peg$FAILED) {\n                  s5.push(s6);\n                  s6 = peg$parseoptionalFormatPattern();\n                }\n              } else {\n                s5 = peg$FAILED;\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c27(s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseselector() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 61) {\n        s2 = peg$c28;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c29);\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenumber();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s0 = input.substring(s0, peg$currPos);\n      } else {\n        s0 = s1;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsechars();\n      }\n      return s0;\n    }\n    function peg$parseoptionalFormatPattern() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseselector();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 123) {\n              s4 = peg$c5;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c6);\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parsemessageFormatPattern();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parse_();\n                  if (s7 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 125) {\n                      s8 = peg$c9;\n                      peg$currPos++;\n                    } else {\n                      s8 = peg$FAILED;\n                      if (peg$silentFails === 0) {\n                        peg$fail(peg$c10);\n                      }\n                    }\n                    if (s8 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c30(s2, s6);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseoffset() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 7) === peg$c31) {\n        s1 = peg$c31;\n        peg$currPos += 7;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c32);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsenumber();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c33(s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsepluralStyle() {\n      var s0, s1, s2, s3, s4;\n      s0 = peg$currPos;\n      s1 = peg$parseoffset();\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parseoptionalFormatPattern();\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parseoptionalFormatPattern();\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c34(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parsews() {\n      var s0, s1;\n      peg$silentFails++;\n      s0 = [];\n      if (peg$c36.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c37);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          if (peg$c36.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c37);\n            }\n          }\n        }\n      } else {\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c35);\n        }\n      }\n      return s0;\n    }\n    function peg$parse_() {\n      var s0, s1, s2;\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsews();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsews();\n      }\n      if (s1 !== peg$FAILED) {\n        s0 = input.substring(s0, peg$currPos);\n      } else {\n        s0 = s1;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c38);\n        }\n      }\n      return s0;\n    }\n    function peg$parsedigit() {\n      var s0;\n      if (peg$c39.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c40);\n        }\n      }\n      return s0;\n    }\n    function peg$parsehexDigit() {\n      var s0;\n      if (peg$c41.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c42);\n        }\n      }\n      return s0;\n    }\n    function peg$parsenumber() {\n      var s0, s1, s2, s3, s4, s5;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 48) {\n        s1 = peg$c43;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c44);\n        }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$currPos;\n        if (peg$c45.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c46);\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parsedigit();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parsedigit();\n          }\n          if (s4 !== peg$FAILED) {\n            s3 = [s3, s4];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = input.substring(s1, peg$currPos);\n        } else {\n          s1 = s2;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c47(s1);\n      }\n      s0 = s1;\n      return s0;\n    }\n    function peg$parsechar() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n      if (peg$c48.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c49);\n        }\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 2) === peg$c50) {\n          s1 = peg$c50;\n          peg$currPos += 2;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c51);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c52();\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 2) === peg$c53) {\n            s1 = peg$c53;\n            peg$currPos += 2;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c54);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c55();\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.substr(peg$currPos, 2) === peg$c56) {\n              s1 = peg$c56;\n              peg$currPos += 2;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c57);\n              }\n            }\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c58();\n            }\n            s0 = s1;\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              if (input.substr(peg$currPos, 2) === peg$c59) {\n                s1 = peg$c59;\n                peg$currPos += 2;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$c60);\n                }\n              }\n              if (s1 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c61();\n              }\n              s0 = s1;\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                if (input.substr(peg$currPos, 2) === peg$c62) {\n                  s1 = peg$c62;\n                  peg$currPos += 2;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$c63);\n                  }\n                }\n                if (s1 !== peg$FAILED) {\n                  s2 = peg$currPos;\n                  s3 = peg$currPos;\n                  s4 = peg$parsehexDigit();\n                  if (s4 !== peg$FAILED) {\n                    s5 = peg$parsehexDigit();\n                    if (s5 !== peg$FAILED) {\n                      s6 = peg$parsehexDigit();\n                      if (s6 !== peg$FAILED) {\n                        s7 = peg$parsehexDigit();\n                        if (s7 !== peg$FAILED) {\n                          s4 = [s4, s5, s6, s7];\n                          s3 = s4;\n                        } else {\n                          peg$currPos = s3;\n                          s3 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s3;\n                        s3 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                  if (s3 !== peg$FAILED) {\n                    s2 = input.substring(s2, peg$currPos);\n                  } else {\n                    s2 = s3;\n                  }\n                  if (s2 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c64(s2);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              }\n            }\n          }\n        }\n      }\n      return s0;\n    }\n    function peg$parsechars() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsechar();\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsechar();\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c65(s1);\n      }\n      s0 = s1;\n      return s0;\n    }\n    peg$result = peg$startRuleFunction();\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({\n          type: \"end\",\n          description: \"end of input\"\n        });\n      }\n      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n    }\n  }\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n}();","// GENERATED FILE\n\"use strict\";\n\nexports[\"default\"] = {\n  \"locale\": \"en\",\n  \"pluralRuleFunction\": function (n, ord) {\n    var s = String(n).split(\".\"),\n      v0 = !s[1],\n      t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1),\n      n100 = t0 && s[0].slice(-2);\n    if (ord) return n10 == 1 && n100 != 11 ? \"one\" : n10 == 2 && n100 != 12 ? \"two\" : n10 == 3 && n100 != 13 ? \"few\" : \"other\";\n    return n == 1 && v0 ? \"one\" : \"other\";\n  }\n};","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../../_version.js';\nexport const messages = {\n  'invalid-value': _ref => {\n    let {\n      paramName,\n      validValueDescription,\n      value\n    } = _ref;\n    if (!paramName || !validValueDescription) {\n      throw new Error(`Unexpected input to 'invalid-value' error.`);\n    }\n    return `The '${paramName}' parameter was given a value with an ` + `unexpected value. ${validValueDescription} Received a value of ` + `${JSON.stringify(value)}.`;\n  },\n  'not-an-array': _ref2 => {\n    let {\n      moduleName,\n      className,\n      funcName,\n      paramName\n    } = _ref2;\n    if (!moduleName || !className || !funcName || !paramName) {\n      throw new Error(`Unexpected input to 'not-an-array' error.`);\n    }\n    return `The parameter '${paramName}' passed into ` + `'${moduleName}.${className}.${funcName}()' must be an array.`;\n  },\n  'incorrect-type': _ref3 => {\n    let {\n      expectedType,\n      paramName,\n      moduleName,\n      className,\n      funcName\n    } = _ref3;\n    if (!expectedType || !paramName || !moduleName || !funcName) {\n      throw new Error(`Unexpected input to 'incorrect-type' error.`);\n    }\n    const classNameStr = className ? `${className}.` : '';\n    return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}` + `${funcName}()' must be of type ${expectedType}.`;\n  },\n  'incorrect-class': _ref4 => {\n    let {\n      expectedClassName,\n      paramName,\n      moduleName,\n      className,\n      funcName,\n      isReturnValueProblem\n    } = _ref4;\n    if (!expectedClassName || !moduleName || !funcName) {\n      throw new Error(`Unexpected input to 'incorrect-class' error.`);\n    }\n    const classNameStr = className ? `${className}.` : '';\n    if (isReturnValueProblem) {\n      return `The return value from ` + `'${moduleName}.${classNameStr}${funcName}()' ` + `must be an instance of class ${expectedClassName}.`;\n    }\n    return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}${funcName}()' ` + `must be an instance of class ${expectedClassName}.`;\n  },\n  'missing-a-method': _ref5 => {\n    let {\n      expectedMethod,\n      paramName,\n      moduleName,\n      className,\n      funcName\n    } = _ref5;\n    if (!expectedMethod || !paramName || !moduleName || !className || !funcName) {\n      throw new Error(`Unexpected input to 'missing-a-method' error.`);\n    }\n    return `${moduleName}.${className}.${funcName}() expected the ` + `'${paramName}' parameter to expose a '${expectedMethod}' method.`;\n  },\n  'add-to-cache-list-unexpected-type': _ref6 => {\n    let {\n      entry\n    } = _ref6;\n    return `An unexpected entry was passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' The entry ` + `'${JSON.stringify(entry)}' isn't supported. You must supply an array of ` + `strings with one or more characters, objects with a url property or ` + `Request objects.`;\n  },\n  'add-to-cache-list-conflicting-entries': _ref7 => {\n    let {\n      firstEntry,\n      secondEntry\n    } = _ref7;\n    if (!firstEntry || !secondEntry) {\n      throw new Error(`Unexpected input to ` + `'add-to-cache-list-duplicate-entries' error.`);\n    }\n    return `Two of the entries passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` + `${firstEntry} but different revision details. Workbox is ` + `unable to cache and version the asset correctly. Please remove one ` + `of the entries.`;\n  },\n  'plugin-error-request-will-fetch': _ref8 => {\n    let {\n      thrownErrorMessage\n    } = _ref8;\n    if (!thrownErrorMessage) {\n      throw new Error(`Unexpected input to ` + `'plugin-error-request-will-fetch', error.`);\n    }\n    return `An error was thrown by a plugins 'requestWillFetch()' method. ` + `The thrown error message was: '${thrownErrorMessage}'.`;\n  },\n  'invalid-cache-name': _ref9 => {\n    let {\n      cacheNameId,\n      value\n    } = _ref9;\n    if (!cacheNameId) {\n      throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);\n    }\n    return `You must provide a name containing at least one character for ` + `setCacheDetails({${cacheNameId}: '...'}). Received a value of ` + `'${JSON.stringify(value)}'`;\n  },\n  'unregister-route-but-not-found-with-method': _ref10 => {\n    let {\n      method\n    } = _ref10;\n    if (!method) {\n      throw new Error(`Unexpected input to ` + `'unregister-route-but-not-found-with-method' error.`);\n    }\n    return `The route you're trying to unregister was not  previously ` + `registered for the method type '${method}'.`;\n  },\n  'unregister-route-route-not-registered': () => {\n    return `The route you're trying to unregister was not previously ` + `registered.`;\n  },\n  'queue-replay-failed': _ref11 => {\n    let {\n      name\n    } = _ref11;\n    return `Replaying the background sync queue '${name}' failed.`;\n  },\n  'duplicate-queue-name': _ref12 => {\n    let {\n      name\n    } = _ref12;\n    return `The Queue name '${name}' is already being used. ` + `All instances of backgroundSync.Queue must be given unique names.`;\n  },\n  'expired-test-without-max-age': _ref13 => {\n    let {\n      methodName,\n      paramName\n    } = _ref13;\n    return `The '${methodName}()' method can only be used when the ` + `'${paramName}' is used in the constructor.`;\n  },\n  'unsupported-route-type': _ref14 => {\n    let {\n      moduleName,\n      className,\n      funcName,\n      paramName\n    } = _ref14;\n    return `The supplied '${paramName}' parameter was an unsupported type. ` + `Please check the docs for ${moduleName}.${className}.${funcName} for ` + `valid input types.`;\n  },\n  'not-array-of-class': _ref15 => {\n    let {\n      value,\n      expectedClass,\n      moduleName,\n      className,\n      funcName,\n      paramName\n    } = _ref15;\n    return `The supplied '${paramName}' parameter must be an array of ` + `'${expectedClass}' objects. Received '${JSON.stringify(value)},'. ` + `Please check the call to ${moduleName}.${className}.${funcName}() ` + `to fix the issue.`;\n  },\n  'max-entries-or-age-required': _ref16 => {\n    let {\n      moduleName,\n      className,\n      funcName\n    } = _ref16;\n    return `You must define either config.maxEntries or config.maxAgeSeconds` + `in ${moduleName}.${className}.${funcName}`;\n  },\n  'statuses-or-headers-required': _ref17 => {\n    let {\n      moduleName,\n      className,\n      funcName\n    } = _ref17;\n    return `You must define either config.statuses or config.headers` + `in ${moduleName}.${className}.${funcName}`;\n  },\n  'invalid-string': _ref18 => {\n    let {\n      moduleName,\n      funcName,\n      paramName\n    } = _ref18;\n    if (!paramName || !moduleName || !funcName) {\n      throw new Error(`Unexpected input to 'invalid-string' error.`);\n    }\n    return `When using strings, the '${paramName}' parameter must start with ` + `'http' (for cross-origin matches) or '/' (for same-origin matches). ` + `Please see the docs for ${moduleName}.${funcName}() for ` + `more info.`;\n  },\n  'channel-name-required': () => {\n    return `You must provide a channelName to construct a ` + `BroadcastCacheUpdate instance.`;\n  },\n  'invalid-responses-are-same-args': () => {\n    return `The arguments passed into responsesAreSame() appear to be ` + `invalid. Please ensure valid Responses are used.`;\n  },\n  'expire-custom-caches-only': () => {\n    return `You must provide a 'cacheName' property when using the ` + `expiration plugin with a runtime caching strategy.`;\n  },\n  'unit-must-be-bytes': _ref19 => {\n    let {\n      normalizedRangeHeader\n    } = _ref19;\n    if (!normalizedRangeHeader) {\n      throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);\n    }\n    return `The 'unit' portion of the Range header must be set to 'bytes'. ` + `The Range header provided was \"${normalizedRangeHeader}\"`;\n  },\n  'single-range-only': _ref20 => {\n    let {\n      normalizedRangeHeader\n    } = _ref20;\n    if (!normalizedRangeHeader) {\n      throw new Error(`Unexpected input to 'single-range-only' error.`);\n    }\n    return `Multiple ranges are not supported. Please use a  single start ` + `value, and optional end value. The Range header provided was ` + `\"${normalizedRangeHeader}\"`;\n  },\n  'invalid-range-values': _ref21 => {\n    let {\n      normalizedRangeHeader\n    } = _ref21;\n    if (!normalizedRangeHeader) {\n      throw new Error(`Unexpected input to 'invalid-range-values' error.`);\n    }\n    return `The Range header is missing both start and end values. At least ` + `one of those values is needed. The Range header provided was ` + `\"${normalizedRangeHeader}\"`;\n  },\n  'no-range-header': () => {\n    return `No Range header was found in the Request provided.`;\n  },\n  'range-not-satisfiable': _ref22 => {\n    let {\n      size,\n      start,\n      end\n    } = _ref22;\n    return `The start (${start}) and end (${end}) values in the Range are ` + `not satisfiable by the cached response, which is ${size} bytes.`;\n  },\n  'attempt-to-cache-non-get-request': _ref23 => {\n    let {\n      url,\n      method\n    } = _ref23;\n    return `Unable to cache '${url}' because it is a '${method}' request and ` + `only 'GET' requests can be cached.`;\n  },\n  'cache-put-with-no-response': _ref24 => {\n    let {\n      url\n    } = _ref24;\n    return `There was an attempt to cache '${url}' but the response was not ` + `defined.`;\n  },\n  'no-response': _ref25 => {\n    let {\n      url,\n      error\n    } = _ref25;\n    let message = `The strategy could not generate a response for '${url}'.`;\n    if (error) {\n      message += ` The underlying error is ${error}.`;\n    }\n    return message;\n  },\n  'bad-precaching-response': _ref26 => {\n    let {\n      url,\n      status\n    } = _ref26;\n    return `The precaching request for '${url}' failed` + (status ? ` with an HTTP status of ${status}.` : `.`);\n  },\n  'non-precached-url': _ref27 => {\n    let {\n      url\n    } = _ref27;\n    return `createHandlerBoundToURL('${url}') was called, but that URL is ` + `not precached. Please pass in a URL that is precached instead.`;\n  },\n  'add-to-cache-list-conflicting-integrities': _ref28 => {\n    let {\n      url\n    } = _ref28;\n    return `Two of the entries passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` + `${url} with different integrity values. Please remove one of them.`;\n  },\n  'missing-precache-entry': _ref29 => {\n    let {\n      cacheName,\n      url\n    } = _ref29;\n    return `Unable to find a precached response in ${cacheName} for ${url}.`;\n  },\n  'cross-origin-copy-response': _ref30 => {\n    let {\n      origin\n    } = _ref30;\n    return `workbox-core.copyResponse() can only be used with same-origin ` + `responses. It was passed a response with origin ${origin}.`;\n  },\n  'opaque-streams-source': _ref31 => {\n    let {\n      type\n    } = _ref31;\n    const message = `One of the workbox-streams sources resulted in an ` + `'${type}' response.`;\n    if (type === 'opaqueredirect') {\n      return `${message} Please do not use a navigation request that results ` + `in a redirect as a source.`;\n    }\n    return `${message} Please ensure your sources are CORS-enabled.`;\n  }\n};","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { messages } from './messages.js';\nimport '../../_version.js';\nconst fallback = function (code) {\n  let msg = code;\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  if (args.length > 0) {\n    msg += ` :: ${JSON.stringify(args)}`;\n  }\n  return msg;\n};\nconst generatorFunction = function (code, details) {\n  if (details === void 0) {\n    details = {};\n  }\n  const message = messages[code];\n  if (!message) {\n    throw new Error(`Unable to find message for code '${code}'.`);\n  }\n  return message(details);\n};\nexport const messageGenerator = process.env.NODE_ENV === 'production' ? fallback : generatorFunction;","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { messageGenerator } from '../models/messages/messageGenerator.js';\nimport '../_version.js';\n/**\n * Workbox errors should be thrown with this class.\n * This allows use to ensure the type easily in tests,\n * helps developers identify errors from workbox\n * easily and allows use to optimise error\n * messages correctly.\n *\n * @private\n */\nclass WorkboxError extends Error {\n  /**\n   *\n   * @param {string} errorCode The error code that\n   * identifies this particular error.\n   * @param {Object=} details Any relevant arguments\n   * that will help developers identify issues should\n   * be added as a key on the context object.\n   */\n  constructor(errorCode, details) {\n    const message = messageGenerator(errorCode, details);\n    super(message);\n    this.name = errorCode;\n    this.details = details;\n  }\n}\nexport { WorkboxError };","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A helper function that prevents a promise from being flagged as unused.\n *\n * @private\n **/\nexport function dontWaitFor(promise) {\n  // Effective no-op.\n  void promise.then(() => {});\n}","const instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n  return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n  return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]);\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n  const promise = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      request.removeEventListener('success', success);\n      request.removeEventListener('error', error);\n    };\n    const success = () => {\n      resolve(wrap(request.result));\n      unlisten();\n    };\n    const error = () => {\n      reject(request.error);\n      unlisten();\n    };\n    request.addEventListener('success', success);\n    request.addEventListener('error', error);\n  });\n  promise.then(value => {\n    // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n    // (see wrapFunction).\n    if (value instanceof IDBCursor) {\n      cursorRequestMap.set(value, request);\n    }\n    // Catching to avoid \"Uncaught Promise exceptions\"\n  }).catch(() => {});\n  // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n  // is because we create many promises from a single IDBRequest.\n  reverseTransformCache.set(promise, request);\n  return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n  // Early bail if we've already created a done promise for this transaction.\n  if (transactionDoneMap.has(tx)) return;\n  const done = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      tx.removeEventListener('complete', complete);\n      tx.removeEventListener('error', error);\n      tx.removeEventListener('abort', error);\n    };\n    const complete = () => {\n      resolve();\n      unlisten();\n    };\n    const error = () => {\n      reject(tx.error || new DOMException('AbortError', 'AbortError'));\n      unlisten();\n    };\n    tx.addEventListener('complete', complete);\n    tx.addEventListener('error', error);\n    tx.addEventListener('abort', error);\n  });\n  // Cache it for later retrieval.\n  transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n  get(target, prop, receiver) {\n    if (target instanceof IDBTransaction) {\n      // Special handling for transaction.done.\n      if (prop === 'done') return transactionDoneMap.get(target);\n      // Polyfill for objectStoreNames because of Edge.\n      if (prop === 'objectStoreNames') {\n        return target.objectStoreNames || transactionStoreNamesMap.get(target);\n      }\n      // Make tx.store return the only store in the transaction, or undefined if there are many.\n      if (prop === 'store') {\n        return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);\n      }\n    }\n    // Else transform whatever we get back.\n    return wrap(target[prop]);\n  },\n  set(target, prop, value) {\n    target[prop] = value;\n    return true;\n  },\n  has(target, prop) {\n    if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {\n      return true;\n    }\n    return prop in target;\n  }\n};\nfunction replaceTraps(callback) {\n  idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n  // Due to expected object equality (which is enforced by the caching in `wrap`), we\n  // only create one new func per func.\n  // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n  if (func === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)) {\n    return function (storeNames) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      const tx = func.call(unwrap(this), storeNames, ...args);\n      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n      return wrap(tx);\n    };\n  }\n  // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n  // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n  // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n  // with real promises, so each advance methods returns a new promise for the cursor object, or\n  // undefined if the end of the cursor has been reached.\n  if (getCursorAdvanceMethods().includes(func)) {\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n      // the original object.\n      func.apply(unwrap(this), args);\n      return wrap(cursorRequestMap.get(this));\n    };\n  }\n  return function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n    // the original object.\n    return wrap(func.apply(unwrap(this), args));\n  };\n}\nfunction transformCachableValue(value) {\n  if (typeof value === 'function') return wrapFunction(value);\n  // This doesn't return, it just creates a 'done' promise for the transaction,\n  // which is later returned for transaction.done (see idbObjectHandler).\n  if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);\n  if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps);\n  // Return the same value back if we're not going to transform it.\n  return value;\n}\nfunction wrap(value) {\n  // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n  // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n  if (value instanceof IDBRequest) return promisifyRequest(value);\n  // If we've already transformed this value before, reuse the transformed value.\n  // This is faster, but it also provides object equality.\n  if (transformCache.has(value)) return transformCache.get(value);\n  const newValue = transformCachableValue(value);\n  // Not all types are transformed.\n  // These may be primitive types, so they can't be WeakMap keys.\n  if (newValue !== value) {\n    transformCache.set(value, newValue);\n    reverseTransformCache.set(newValue, value);\n  }\n  return newValue;\n}\nconst unwrap = value => reverseTransformCache.get(value);\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, _temp) {\n  let {\n    blocked,\n    upgrade,\n    blocking,\n    terminated\n  } = _temp === void 0 ? {} : _temp;\n  const request = indexedDB.open(name, version);\n  const openPromise = wrap(request);\n  if (upgrade) {\n    request.addEventListener('upgradeneeded', event => {\n      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\n    });\n  }\n  if (blocked) request.addEventListener('blocked', () => blocked());\n  openPromise.then(db => {\n    if (terminated) db.addEventListener('close', () => terminated());\n    if (blocking) db.addEventListener('versionchange', () => blocking());\n  }).catch(() => {});\n  return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, _temp2) {\n  let {\n    blocked\n  } = _temp2 === void 0 ? {} : _temp2;\n  const request = indexedDB.deleteDatabase(name);\n  if (blocked) request.addEventListener('blocked', () => blocked());\n  return wrap(request).then(() => undefined);\n}\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) {\n    return;\n  }\n  if (cachedMethods.get(prop)) return cachedMethods.get(prop);\n  const targetFuncName = prop.replace(/FromIndex$/, '');\n  const useIndex = prop !== targetFuncName;\n  const isWrite = writeMethods.includes(targetFuncName);\n  if (\n  // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n  !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {\n    return;\n  }\n  const method = async function (storeName) {\n    // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n    const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n    let target = tx.store;\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    if (useIndex) target = target.index(args.shift());\n    // Must reject if op rejects.\n    // If it's a write operation, must reject if tx.done rejects.\n    // Must reject with op rejection first.\n    // Must resolve with op value.\n    // Must handle both promises (no unhandled rejections)\n    return (await Promise.all([target[targetFuncName](...args), isWrite && tx.done]))[0];\n  };\n  cachedMethods.set(prop, method);\n  return method;\n}\nreplaceTraps(oldTraps => ({\n  ...oldTraps,\n  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)\n}));\nexport { deleteDB, openDB };","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { openDB, deleteDB } from 'idb';\nimport '../_version.js';\nconst DB_NAME = 'workbox-expiration';\nconst CACHE_OBJECT_STORE = 'cache-entries';\nconst normalizeURL = unNormalizedUrl => {\n  const url = new URL(unNormalizedUrl, location.href);\n  url.hash = '';\n  return url.href;\n};\n/**\n * Returns the timestamp model.\n *\n * @private\n */\nclass CacheTimestampsModel {\n  /**\n   *\n   * @param {string} cacheName\n   *\n   * @private\n   */\n  constructor(cacheName) {\n    this._db = null;\n    this._cacheName = cacheName;\n  }\n  /**\n   * Performs an upgrade of indexedDB.\n   *\n   * @param {IDBPDatabase<CacheDbSchema>} db\n   *\n   * @private\n   */\n  _upgradeDb(db) {\n    // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\n    // have to use the `id` keyPath here and create our own values (a\n    // concatenation of `url + cacheName`) instead of simply using\n    // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\n    const objStore = db.createObjectStore(CACHE_OBJECT_STORE, {\n      keyPath: 'id'\n    });\n    // TODO(philipwalton): once we don't have to support EdgeHTML, we can\n    // create a single index with the keyPath `['cacheName', 'timestamp']`\n    // instead of doing both these indexes.\n    objStore.createIndex('cacheName', 'cacheName', {\n      unique: false\n    });\n    objStore.createIndex('timestamp', 'timestamp', {\n      unique: false\n    });\n  }\n  /**\n   * Performs an upgrade of indexedDB and deletes deprecated DBs.\n   *\n   * @param {IDBPDatabase<CacheDbSchema>} db\n   *\n   * @private\n   */\n  _upgradeDbAndDeleteOldDbs(db) {\n    this._upgradeDb(db);\n    if (this._cacheName) {\n      void deleteDB(this._cacheName);\n    }\n  }\n  /**\n   * @param {string} url\n   * @param {number} timestamp\n   *\n   * @private\n   */\n  async setTimestamp(url, timestamp) {\n    url = normalizeURL(url);\n    const entry = {\n      url,\n      timestamp,\n      cacheName: this._cacheName,\n      // Creating an ID from the URL and cache name won't be necessary once\n      // Edge switches to Chromium and all browsers we support work with\n      // array keyPaths.\n      id: this._getId(url)\n    };\n    const db = await this.getDb();\n    const tx = db.transaction(CACHE_OBJECT_STORE, 'readwrite', {\n      durability: 'relaxed'\n    });\n    await tx.store.put(entry);\n    await tx.done;\n  }\n  /**\n   * Returns the timestamp stored for a given URL.\n   *\n   * @param {string} url\n   * @return {number | undefined}\n   *\n   * @private\n   */\n  async getTimestamp(url) {\n    const db = await this.getDb();\n    const entry = await db.get(CACHE_OBJECT_STORE, this._getId(url));\n    return entry === null || entry === void 0 ? void 0 : entry.timestamp;\n  }\n  /**\n   * Iterates through all the entries in the object store (from newest to\n   * oldest) and removes entries once either `maxCount` is reached or the\n   * entry's timestamp is less than `minTimestamp`.\n   *\n   * @param {number} minTimestamp\n   * @param {number} maxCount\n   * @return {Array<string>}\n   *\n   * @private\n   */\n  async expireEntries(minTimestamp, maxCount) {\n    const db = await this.getDb();\n    let cursor = await db.transaction(CACHE_OBJECT_STORE).store.index('timestamp').openCursor(null, 'prev');\n    const entriesToDelete = [];\n    let entriesNotDeletedCount = 0;\n    while (cursor) {\n      const result = cursor.value;\n      // TODO(philipwalton): once we can use a multi-key index, we\n      // won't have to check `cacheName` here.\n      if (result.cacheName === this._cacheName) {\n        // Delete an entry if it's older than the max age or\n        // if we already have the max number allowed.\n        if (minTimestamp && result.timestamp < minTimestamp || maxCount && entriesNotDeletedCount >= maxCount) {\n          // TODO(philipwalton): we should be able to delete the\n          // entry right here, but doing so causes an iteration\n          // bug in Safari stable (fixed in TP). Instead we can\n          // store the keys of the entries to delete, and then\n          // delete the separate transactions.\n          // https://github.com/GoogleChrome/workbox/issues/1978\n          // cursor.delete();\n          // We only need to return the URL, not the whole entry.\n          entriesToDelete.push(cursor.value);\n        } else {\n          entriesNotDeletedCount++;\n        }\n      }\n      cursor = await cursor.continue();\n    }\n    // TODO(philipwalton): once the Safari bug in the following issue is fixed,\n    // we should be able to remove this loop and do the entry deletion in the\n    // cursor loop above:\n    // https://github.com/GoogleChrome/workbox/issues/1978\n    const urlsDeleted = [];\n    for (const entry of entriesToDelete) {\n      await db.delete(CACHE_OBJECT_STORE, entry.id);\n      urlsDeleted.push(entry.url);\n    }\n    return urlsDeleted;\n  }\n  /**\n   * Takes a URL and returns an ID that will be unique in the object store.\n   *\n   * @param {string} url\n   * @return {string}\n   *\n   * @private\n   */\n  _getId(url) {\n    // Creating an ID from the URL and cache name won't be necessary once\n    // Edge switches to Chromium and all browsers we support work with\n    // array keyPaths.\n    return this._cacheName + '|' + normalizeURL(url);\n  }\n  /**\n   * Returns an open connection to the database.\n   *\n   * @private\n   */\n  async getDb() {\n    if (!this._db) {\n      this._db = await openDB(DB_NAME, 1, {\n        upgrade: this._upgradeDbAndDeleteOldDbs.bind(this)\n      });\n    }\n    return this._db;\n  }\n}\nexport { CacheTimestampsModel };","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheTimestampsModel } from './models/CacheTimestampsModel.js';\nimport './_version.js';\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof workbox-expiration\n */\nclass CacheExpiration {\n  /**\n   * To construct a new CacheExpiration instance you must provide at least\n   * one of the `config` properties.\n   *\n   * @param {string} cacheName Name of the cache to apply restrictions to.\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\n   * that will be used when calling `delete()` on the cache.\n   */\n  constructor(cacheName, config) {\n    if (config === void 0) {\n      config = {};\n    }\n    this._isRunning = false;\n    this._rerunRequested = false;\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'constructor',\n        paramName: 'cacheName'\n      });\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor'\n        });\n      }\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries'\n        });\n      }\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds'\n        });\n      }\n    }\n    this._maxEntries = config.maxEntries;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._matchOptions = config.matchOptions;\n    this._cacheName = cacheName;\n    this._timestampModel = new CacheTimestampsModel(cacheName);\n  }\n  /**\n   * Expires entries for the given cache and given criteria.\n   */\n  async expireEntries() {\n    if (this._isRunning) {\n      this._rerunRequested = true;\n      return;\n    }\n    this._isRunning = true;\n    const minTimestamp = this._maxAgeSeconds ? Date.now() - this._maxAgeSeconds * 1000 : 0;\n    const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);\n    // Delete URLs from the cache\n    const cache = await self.caches.open(this._cacheName);\n    for (const url of urlsExpired) {\n      await cache.delete(url, this._matchOptions);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      if (urlsExpired.length > 0) {\n        logger.groupCollapsed(`Expired ${urlsExpired.length} ` + `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` + `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` + `'${this._cacheName}' cache.`);\n        logger.log(`Expired the following ${urlsExpired.length === 1 ? 'URL' : 'URLs'}:`);\n        urlsExpired.forEach(url => logger.log(`    ${url}`));\n        logger.groupEnd();\n      } else {\n        logger.debug(`Cache expiration ran and found no entries to remove.`);\n      }\n    }\n    this._isRunning = false;\n    if (this._rerunRequested) {\n      this._rerunRequested = false;\n      dontWaitFor(this.expireEntries());\n    }\n  }\n  /**\n   * Update the timestamp for the given URL. This ensures the when\n   * removing entries based on maximum entries, most recently used\n   * is accurate or when expiring, the timestamp is up-to-date.\n   *\n   * @param {string} url\n   */\n  async updateTimestamp(url) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(url, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'updateTimestamp',\n        paramName: 'url'\n      });\n    }\n    await this._timestampModel.setTimestamp(url, Date.now());\n  }\n  /**\n   * Can be used to check if a URL has expired or not before it's used.\n   *\n   * This requires a look up from IndexedDB, so can be slow.\n   *\n   * Note: This method will not remove the cached entry, call\n   * `expireEntries()` to remove indexedDB and Cache entries.\n   *\n   * @param {string} url\n   * @return {boolean}\n   */\n  async isURLExpired(url) {\n    if (!this._maxAgeSeconds) {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new WorkboxError(`expired-test-without-max-age`, {\n          methodName: 'isURLExpired',\n          paramName: 'maxAgeSeconds'\n        });\n      }\n      return false;\n    } else {\n      const timestamp = await this._timestampModel.getTimestamp(url);\n      const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\n      return timestamp !== undefined ? timestamp < expireOlderThan : true;\n    }\n  }\n  /**\n   * Removes the IndexedDB object store used to keep track of cache expiration\n   * metadata.\n   */\n  async delete() {\n    // Make sure we don't attempt another rerun if we're called in the middle of\n    // a cache expiration.\n    this._rerunRequested = false;\n    await this._timestampModel.expireEntries(Infinity); // Expires all.\n  }\n}\n\nexport { CacheExpiration };","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nconst _cacheNameDetails = {\n  googleAnalytics: 'googleAnalytics',\n  precache: 'precache-v2',\n  prefix: 'workbox',\n  runtime: 'runtime',\n  suffix: typeof registration !== 'undefined' ? registration.scope : ''\n};\nconst _createCacheName = cacheName => {\n  return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix].filter(value => value && value.length > 0).join('-');\n};\nconst eachCacheNameDetail = fn => {\n  for (const key of Object.keys(_cacheNameDetails)) {\n    fn(key);\n  }\n};\nexport const cacheNames = {\n  updateDetails: details => {\n    eachCacheNameDetail(key => {\n      if (typeof details[key] === 'string') {\n        _cacheNameDetails[key] = details[key];\n      }\n    });\n  },\n  getGoogleAnalyticsName: userCacheName => {\n    return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n  },\n  getPrecacheName: userCacheName => {\n    return userCacheName || _createCacheName(_cacheNameDetails.precache);\n  },\n  getPrefix: () => {\n    return _cacheNameDetails.prefix;\n  },\n  getRuntimeName: userCacheName => {\n    return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n  },\n  getSuffix: () => {\n    return _cacheNameDetails.suffix;\n  }\n};","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nconst getFriendlyURL = url => {\n  const urlObj = new URL(String(url), location.href);\n  // See https://github.com/GoogleChrome/workbox/issues/2323\n  // We want to include everything, except for the origin if it's same-origin.\n  return urlObj.href.replace(new RegExp(`^${location.origin}`), '');\n};\nexport { getFriendlyURL };","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n// Callbacks to be executed whenever there's a quota error.\n// Can't change Function type right now.\n// eslint-disable-next-line @typescript-eslint/ban-types\nconst quotaErrorCallbacks = new Set();\nexport { quotaErrorCallbacks };","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { registerQuotaErrorCallback } from 'workbox-core/registerQuotaErrorCallback.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheExpiration } from './CacheExpiration.js';\nimport './_version.js';\n/**\n * This plugin can be used in a `workbox-strategy` to regularly enforce a\n * limit on the age and / or the number of cached requests.\n *\n * It can only be used with `workbox-strategy` instances that have a\n * [custom `cacheName` property set](/web/tools/workbox/guides/configure-workbox#custom_cache_names_in_strategies).\n * In other words, it can't be used to expire entries in strategy that uses the\n * default runtime cache name.\n *\n * Whenever a cached response is used or updated, this plugin will look\n * at the associated cache and remove any old or extra responses.\n *\n * When using `maxAgeSeconds`, responses may be used *once* after expiring\n * because the expiration clean up will not have occurred until *after* the\n * cached response has been used. If the response has a \"Date\" header, then\n * a light weight expiration check is performed and the response will not be\n * used immediately.\n *\n * When using `maxEntries`, the entry least-recently requested will be removed\n * from the cache first.\n *\n * @memberof workbox-expiration\n */\nclass ExpirationPlugin {\n  /**\n   * @param {ExpirationPluginOptions} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\n   * that will be used when calling `delete()` on the cache.\n   * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n   * automatic deletion if the available storage quota has been exceeded.\n   */\n  constructor(config) {\n    if (config === void 0) {\n      config = {};\n    }\n    /**\n     * A \"lifecycle\" callback that will be triggered automatically by the\n     * `workbox-strategies` handlers when a `Response` is about to be returned\n     * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n     * the handler. It allows the `Response` to be inspected for freshness and\n     * prevents it from being used if the `Response`'s `Date` header value is\n     * older than the configured `maxAgeSeconds`.\n     *\n     * @param {Object} options\n     * @param {string} options.cacheName Name of the cache the response is in.\n     * @param {Response} options.cachedResponse The `Response` object that's been\n     *     read from a cache and whose freshness should be checked.\n     * @return {Response} Either the `cachedResponse`, if it's\n     *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n     *\n     * @private\n     */\n    this.cachedResponseWillBeUsed = async _ref => {\n      let {\n        event,\n        request,\n        cacheName,\n        cachedResponse\n      } = _ref;\n      if (!cachedResponse) {\n        return null;\n      }\n      const isFresh = this._isResponseDateFresh(cachedResponse);\n      // Expire entries to ensure that even if the expiration date has\n      // expired, it'll only be used once.\n      const cacheExpiration = this._getCacheExpiration(cacheName);\n      dontWaitFor(cacheExpiration.expireEntries());\n      // Update the metadata for the request URL to the current timestamp,\n      // but don't `await` it as we don't want to block the response.\n      const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n      if (event) {\n        try {\n          event.waitUntil(updateTimestampDone);\n        } catch (error) {\n          if (process.env.NODE_ENV !== 'production') {\n            // The event may not be a fetch event; only log the URL if it is.\n            if ('request' in event) {\n              logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache entry for ` + `'${getFriendlyURL(event.request.url)}'.`);\n            }\n          }\n        }\n      }\n      return isFresh ? cachedResponse : null;\n    };\n    /**\n     * A \"lifecycle\" callback that will be triggered automatically by the\n     * `workbox-strategies` handlers when an entry is added to a cache.\n     *\n     * @param {Object} options\n     * @param {string} options.cacheName Name of the cache that was updated.\n     * @param {string} options.request The Request for the cached entry.\n     *\n     * @private\n     */\n    this.cacheDidUpdate = async _ref2 => {\n      let {\n        cacheName,\n        request\n      } = _ref2;\n      if (process.env.NODE_ENV !== 'production') {\n        assert.isType(cacheName, 'string', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'cacheDidUpdate',\n          paramName: 'cacheName'\n        });\n        assert.isInstance(request, Request, {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'cacheDidUpdate',\n          paramName: 'request'\n        });\n      }\n      const cacheExpiration = this._getCacheExpiration(cacheName);\n      await cacheExpiration.updateTimestamp(request.url);\n      await cacheExpiration.expireEntries();\n    };\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor'\n        });\n      }\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries'\n        });\n      }\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds'\n        });\n      }\n    }\n    this._config = config;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheExpirations = new Map();\n    if (config.purgeOnQuotaError) {\n      registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n    }\n  }\n  /**\n   * A simple helper method to return a CacheExpiration instance for a given\n   * cache name.\n   *\n   * @param {string} cacheName\n   * @return {CacheExpiration}\n   *\n   * @private\n   */\n  _getCacheExpiration(cacheName) {\n    if (cacheName === cacheNames.getRuntimeName()) {\n      throw new WorkboxError('expire-custom-caches-only');\n    }\n    let cacheExpiration = this._cacheExpirations.get(cacheName);\n    if (!cacheExpiration) {\n      cacheExpiration = new CacheExpiration(cacheName, this._config);\n      this._cacheExpirations.set(cacheName, cacheExpiration);\n    }\n    return cacheExpiration;\n  }\n  /**\n   * @param {Response} cachedResponse\n   * @return {boolean}\n   *\n   * @private\n   */\n  _isResponseDateFresh(cachedResponse) {\n    if (!this._maxAgeSeconds) {\n      // We aren't expiring by age, so return true, it's fresh\n      return true;\n    }\n    // Check if the 'date' header will suffice a quick expiration check.\n    // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n    // discussion.\n    const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n    if (dateHeaderTimestamp === null) {\n      // Unable to parse date, so assume it's fresh.\n      return true;\n    }\n    // If we have a valid headerTime, then our response is fresh iff the\n    // headerTime plus maxAgeSeconds is greater than the current time.\n    const now = Date.now();\n    return dateHeaderTimestamp >= now - this._maxAgeSeconds * 1000;\n  }\n  /**\n   * This method will extract the data header and parse it into a useful\n   * value.\n   *\n   * @param {Response} cachedResponse\n   * @return {number|null}\n   *\n   * @private\n   */\n  _getDateHeaderTimestamp(cachedResponse) {\n    if (!cachedResponse.headers.has('date')) {\n      return null;\n    }\n    const dateHeader = cachedResponse.headers.get('date');\n    const parsedDate = new Date(dateHeader);\n    const headerTime = parsedDate.getTime();\n    // If the Date header was invalid for some reason, parsedDate.getTime()\n    // will return NaN.\n    if (isNaN(headerTime)) {\n      return null;\n    }\n    return headerTime;\n  }\n  /**\n   * This is a helper method that performs two operations:\n   *\n   * - Deletes *all* the underlying Cache instances associated with this plugin\n   * instance, by calling caches.delete() on your behalf.\n   * - Deletes the metadata from IndexedDB used to keep track of expiration\n   * details for each Cache instance.\n   *\n   * When using cache expiration, calling this method is preferable to calling\n   * `caches.delete()` directly, since this will ensure that the IndexedDB\n   * metadata is also cleanly removed and open IndexedDB instances are deleted.\n   *\n   * Note that if you're *not* using cache expiration for a given cache, calling\n   * `caches.delete()` and passing in the cache's name should be sufficient.\n   * There is no Workbox-specific method needed for cleanup in that case.\n   */\n  async deleteCacheAndMetadata() {\n    // Do this one at a time instead of all at once via `Promise.all()` to\n    // reduce the chance of inconsistency if a promise rejects.\n    for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n      await self.caches.delete(cacheName);\n      await cacheExpiration.delete();\n    }\n    // Reset this._cacheExpirations to its initial state.\n    this._cacheExpirations = new Map();\n  }\n}\nexport { ExpirationPlugin };","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from './_private/logger.js';\nimport { assert } from './_private/assert.js';\nimport { quotaErrorCallbacks } from './models/quotaErrorCallbacks.js';\nimport './_version.js';\n/**\n * Adds a function to the set of quotaErrorCallbacks that will be executed if\n * there's a quota error.\n *\n * @param {Function} callback\n * @memberof workbox-core\n */\n// Can't change Function type\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction registerQuotaErrorCallback(callback) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isType(callback, 'function', {\n      moduleName: 'workbox-core',\n      funcName: 'register',\n      paramName: 'callback'\n    });\n  }\n  quotaErrorCallbacks.add(callback);\n  if (process.env.NODE_ENV !== 'production') {\n    logger.log('Registered a callback to respond to quota errors.', callback);\n  }\n}\nexport { registerQuotaErrorCallback };","/*\n  Copyright 2020 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A utility method that makes it easier to use `event.waitUntil` with\n * async functions and return the result.\n *\n * @param {ExtendableEvent} event\n * @param {Function} asyncFn\n * @return {Function}\n * @private\n */\nfunction waitUntil(event, asyncFn) {\n  const returnPromise = asyncFn();\n  event.waitUntil(returnPromise);\n  return returnPromise;\n}\nexport { waitUntil };","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport '../_version.js';\n// Name of the search parameter used to store revision info.\nconst REVISION_SEARCH_PARAM = '__WB_REVISION__';\n/**\n * Converts a manifest entry into a versioned URL suitable for precaching.\n *\n * @param {Object|string} entry\n * @return {string} A URL with versioning info.\n *\n * @private\n * @memberof workbox-precaching\n */\nexport function createCacheKey(entry) {\n  if (!entry) {\n    throw new WorkboxError('add-to-cache-list-unexpected-type', {\n      entry\n    });\n  }\n  // If a precache manifest entry is a string, it's assumed to be a versioned\n  // URL, like '/app.abcd1234.js'. Return as-is.\n  if (typeof entry === 'string') {\n    const urlObject = new URL(entry, location.href);\n    return {\n      cacheKey: urlObject.href,\n      url: urlObject.href\n    };\n  }\n  const {\n    revision,\n    url\n  } = entry;\n  if (!url) {\n    throw new WorkboxError('add-to-cache-list-unexpected-type', {\n      entry\n    });\n  }\n  // If there's just a URL and no revision, then it's also assumed to be a\n  // versioned URL.\n  if (!revision) {\n    const urlObject = new URL(url, location.href);\n    return {\n      cacheKey: urlObject.href,\n      url: urlObject.href\n    };\n  }\n  // Otherwise, construct a properly versioned URL using the custom Workbox\n  // search parameter along with the revision info.\n  const cacheKeyURL = new URL(url, location.href);\n  const originalURL = new URL(url, location.href);\n  cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);\n  return {\n    cacheKey: cacheKeyURL.href,\n    url: originalURL.href\n  };\n}","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A plugin, designed to be used with PrecacheController, to determine the\n * of assets that were updated (or not updated) during the install event.\n *\n * @private\n */\nclass PrecacheInstallReportPlugin {\n  constructor() {\n    this.updatedURLs = [];\n    this.notUpdatedURLs = [];\n    this.handlerWillStart = async _ref => {\n      let {\n        request,\n        state\n      } = _ref;\n      // TODO: `state` should never be undefined...\n      if (state) {\n        state.originalRequest = request;\n      }\n    };\n    this.cachedResponseWillBeUsed = async _ref2 => {\n      let {\n        event,\n        state,\n        cachedResponse\n      } = _ref2;\n      if (event.type === 'install') {\n        if (state && state.originalRequest && state.originalRequest instanceof Request) {\n          // TODO: `state` should never be undefined...\n          const url = state.originalRequest.url;\n          if (cachedResponse) {\n            this.notUpdatedURLs.push(url);\n          } else {\n            this.updatedURLs.push(url);\n          }\n        }\n      }\n      return cachedResponse;\n    };\n  }\n}\nexport { PrecacheInstallReportPlugin };","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A plugin, designed to be used with PrecacheController, to translate URLs into\n * the corresponding cache key, based on the current revision info.\n *\n * @private\n */\nclass PrecacheCacheKeyPlugin {\n  constructor(_ref) {\n    let {\n      precacheController\n    } = _ref;\n    this.cacheKeyWillBeUsed = async _ref2 => {\n      let {\n        request,\n        params\n      } = _ref2;\n      // Params is type any, can't change right now.\n      /* eslint-disable */\n      const cacheKey = (params === null || params === void 0 ? void 0 : params.cacheKey) || this._precacheController.getCacheKeyForURL(request.url);\n      /* eslint-enable */\n      return cacheKey ? new Request(cacheKey, {\n        headers: request.headers\n      }) : request;\n    };\n    this._precacheController = precacheController;\n  }\n}\nexport { PrecacheCacheKeyPlugin };","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nlet supportStatus;\n/**\n * A utility function that determines whether the current browser supports\n * constructing a new `Response` from a `response.body` stream.\n *\n * @return {boolean} `true`, if the current browser can successfully\n *     construct a `Response` from a `response.body` stream, `false` otherwise.\n *\n * @private\n */\nfunction canConstructResponseFromBodyStream() {\n  if (supportStatus === undefined) {\n    const testResponse = new Response('');\n    if ('body' in testResponse) {\n      try {\n        new Response(testResponse.body);\n        supportStatus = true;\n      } catch (error) {\n        supportStatus = false;\n      }\n    }\n    supportStatus = false;\n  }\n  return supportStatus;\n}\nexport { canConstructResponseFromBodyStream };","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { canConstructResponseFromBodyStream } from './_private/canConstructResponseFromBodyStream.js';\nimport { WorkboxError } from './_private/WorkboxError.js';\nimport './_version.js';\n/**\n * Allows developers to copy a response and modify its `headers`, `status`,\n * or `statusText` values (the values settable via a\n * [`ResponseInit`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#Syntax}\n * object in the constructor).\n * To modify these values, pass a function as the second argument. That\n * function will be invoked with a single object with the response properties\n * `{headers, status, statusText}`. The return value of this function will\n * be used as the `ResponseInit` for the new `Response`. To change the values\n * either modify the passed parameter(s) and return it, or return a totally\n * new object.\n *\n * This method is intentionally limited to same-origin responses, regardless of\n * whether CORS was used or not.\n *\n * @param {Response} response\n * @param {Function} modifier\n * @memberof workbox-core\n */\nasync function copyResponse(response, modifier) {\n  let origin = null;\n  // If response.url isn't set, assume it's cross-origin and keep origin null.\n  if (response.url) {\n    const responseURL = new URL(response.url);\n    origin = responseURL.origin;\n  }\n  if (origin !== self.location.origin) {\n    throw new WorkboxError('cross-origin-copy-response', {\n      origin\n    });\n  }\n  const clonedResponse = response.clone();\n  // Create a fresh `ResponseInit` object by cloning the headers.\n  const responseInit = {\n    headers: new Headers(clonedResponse.headers),\n    status: clonedResponse.status,\n    statusText: clonedResponse.statusText\n  };\n  // Apply any user modifications.\n  const modifiedResponseInit = modifier ? modifier(responseInit) : responseInit;\n  // Create the new response from the body stream and `ResponseInit`\n  // modifications. Note: not all browsers support the Response.body stream,\n  // so fall back to reading the entire body into memory as a blob.\n  const body = canConstructResponseFromBodyStream() ? clonedResponse.body : await clonedResponse.blob();\n  return new Response(body, modifiedResponseInit);\n}\nexport { copyResponse };","/*\n  Copyright 2020 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nfunction stripParams(fullURL, ignoreParams) {\n  const strippedURL = new URL(fullURL);\n  for (const param of ignoreParams) {\n    strippedURL.searchParams.delete(param);\n  }\n  return strippedURL.href;\n}\n/**\n * Matches an item in the cache, ignoring specific URL params. This is similar\n * to the `ignoreSearch` option, but it allows you to ignore just specific\n * params (while continuing to match on the others).\n *\n * @private\n * @param {Cache} cache\n * @param {Request} request\n * @param {Object} matchOptions\n * @param {Array<string>} ignoreParams\n * @return {Promise<Response|undefined>}\n */\nasync function cacheMatchIgnoreParams(cache, request, ignoreParams, matchOptions) {\n  const strippedRequestURL = stripParams(request.url, ignoreParams);\n  // If the request doesn't include any ignored params, match as normal.\n  if (request.url === strippedRequestURL) {\n    return cache.match(request, matchOptions);\n  }\n  // Otherwise, match by comparing keys\n  const keysOptions = Object.assign(Object.assign({}, matchOptions), {\n    ignoreSearch: true\n  });\n  const cacheKeys = await cache.keys(request, keysOptions);\n  for (const cacheKey of cacheKeys) {\n    const strippedCacheKeyURL = stripParams(cacheKey.url, ignoreParams);\n    if (strippedRequestURL === strippedCacheKeyURL) {\n      return cache.match(cacheKey, matchOptions);\n    }\n  }\n  return;\n}\nexport { cacheMatchIgnoreParams };","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * The Deferred class composes Promises in a way that allows for them to be\n * resolved or rejected from outside the constructor. In most cases promises\n * should be used directly, but Deferreds can be necessary when the logic to\n * resolve a promise must be separate.\n *\n * @private\n */\nclass Deferred {\n  /**\n   * Creates a promise and exposes its resolve and reject functions as methods.\n   */\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n}\nexport { Deferred };","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * Returns a promise that resolves and the passed number of milliseconds.\n * This utility is an async/await-friendly version of `setTimeout`.\n *\n * @param {number} ms\n * @return {Promise}\n * @private\n */\nexport function timeout(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheMatchIgnoreParams } from 'workbox-core/_private/cacheMatchIgnoreParams.js';\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport { executeQuotaErrorCallbacks } from 'workbox-core/_private/executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { timeout } from 'workbox-core/_private/timeout.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport './_version.js';\nfunction toRequest(input) {\n  return typeof input === 'string' ? new Request(input) : input;\n}\n/**\n * A class created every time a Strategy instance instance calls\n * {@link workbox-strategies.Strategy~handle} or\n * {@link workbox-strategies.Strategy~handleAll} that wraps all fetch and\n * cache actions around plugin callbacks and keeps track of when the strategy\n * is \"done\" (i.e. all added `event.waitUntil()` promises have resolved).\n *\n * @memberof workbox-strategies\n */\nclass StrategyHandler {\n  /**\n   * Creates a new instance associated with the passed strategy and event\n   * that's handling the request.\n   *\n   * The constructor also initializes the state that will be passed to each of\n   * the plugins handling this request.\n   *\n   * @param {workbox-strategies.Strategy} strategy\n   * @param {Object} options\n   * @param {Request|string} options.request A request to run this strategy for.\n   * @param {ExtendableEvent} options.event The event associated with the\n   *     request.\n   * @param {URL} [options.url]\n   * @param {*} [options.params] The return value from the\n   *     {@link workbox-routing~matchCallback} (if applicable).\n   */\n  constructor(strategy, options) {\n    this._cacheKeys = {};\n    /**\n     * The request the strategy is performing (passed to the strategy's\n     * `handle()` or `handleAll()` method).\n     * @name request\n     * @instance\n     * @type {Request}\n     * @memberof workbox-strategies.StrategyHandler\n     */\n    /**\n     * The event associated with this request.\n     * @name event\n     * @instance\n     * @type {ExtendableEvent}\n     * @memberof workbox-strategies.StrategyHandler\n     */\n    /**\n     * A `URL` instance of `request.url` (if passed to the strategy's\n     * `handle()` or `handleAll()` method).\n     * Note: the `url` param will be present if the strategy was invoked\n     * from a workbox `Route` object.\n     * @name url\n     * @instance\n     * @type {URL|undefined}\n     * @memberof workbox-strategies.StrategyHandler\n     */\n    /**\n     * A `param` value (if passed to the strategy's\n     * `handle()` or `handleAll()` method).\n     * Note: the `param` param will be present if the strategy was invoked\n     * from a workbox `Route` object and the\n     * {@link workbox-routing~matchCallback} returned\n     * a truthy value (it will be that value).\n     * @name params\n     * @instance\n     * @type {*|undefined}\n     * @memberof workbox-strategies.StrategyHandler\n     */\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(options.event, ExtendableEvent, {\n        moduleName: 'workbox-strategies',\n        className: 'StrategyHandler',\n        funcName: 'constructor',\n        paramName: 'options.event'\n      });\n    }\n    Object.assign(this, options);\n    this.event = options.event;\n    this._strategy = strategy;\n    this._handlerDeferred = new Deferred();\n    this._extendLifetimePromises = [];\n    // Copy the plugins list (since it's mutable on the strategy),\n    // so any mutations don't affect this handler instance.\n    this._plugins = [...strategy.plugins];\n    this._pluginStateMap = new Map();\n    for (const plugin of this._plugins) {\n      this._pluginStateMap.set(plugin, {});\n    }\n    this.event.waitUntil(this._handlerDeferred.promise);\n  }\n  /**\n   * Fetches a given request (and invokes any applicable plugin callback\n   * methods) using the `fetchOptions` (for non-navigation requests) and\n   * `plugins` defined on the `Strategy` object.\n   *\n   * The following plugin lifecycle methods are invoked when using this method:\n   * - `requestWillFetch()`\n   * - `fetchDidSucceed()`\n   * - `fetchDidFail()`\n   *\n   * @param {Request|string} input The URL or request to fetch.\n   * @return {Promise<Response>}\n   */\n  async fetch(input) {\n    const {\n      event\n    } = this;\n    let request = toRequest(input);\n    if (request.mode === 'navigate' && event instanceof FetchEvent && event.preloadResponse) {\n      const possiblePreloadResponse = await event.preloadResponse;\n      if (possiblePreloadResponse) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.log(`Using a preloaded navigation response for ` + `'${getFriendlyURL(request.url)}'`);\n        }\n        return possiblePreloadResponse;\n      }\n    }\n    // If there is a fetchDidFail plugin, we need to save a clone of the\n    // original request before it's either modified by a requestWillFetch\n    // plugin or before the original request's body is consumed via fetch().\n    const originalRequest = this.hasCallback('fetchDidFail') ? request.clone() : null;\n    try {\n      for (const cb of this.iterateCallbacks('requestWillFetch')) {\n        request = await cb({\n          request: request.clone(),\n          event\n        });\n      }\n    } catch (err) {\n      if (err instanceof Error) {\n        throw new WorkboxError('plugin-error-request-will-fetch', {\n          thrownErrorMessage: err.message\n        });\n      }\n    }\n    // The request can be altered by plugins with `requestWillFetch` making\n    // the original request (most likely from a `fetch` event) different\n    // from the Request we make. Pass both to `fetchDidFail` to aid debugging.\n    const pluginFilteredRequest = request.clone();\n    try {\n      let fetchResponse;\n      // See https://github.com/GoogleChrome/workbox/issues/1796\n      fetchResponse = await fetch(request, request.mode === 'navigate' ? undefined : this._strategy.fetchOptions);\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Network request for ` + `'${getFriendlyURL(request.url)}' returned a response with ` + `status '${fetchResponse.status}'.`);\n      }\n      for (const callback of this.iterateCallbacks('fetchDidSucceed')) {\n        fetchResponse = await callback({\n          event,\n          request: pluginFilteredRequest,\n          response: fetchResponse\n        });\n      }\n      return fetchResponse;\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log(`Network request for ` + `'${getFriendlyURL(request.url)}' threw an error.`, error);\n      }\n      // `originalRequest` will only exist if a `fetchDidFail` callback\n      // is being used (see above).\n      if (originalRequest) {\n        await this.runCallbacks('fetchDidFail', {\n          error: error,\n          event,\n          originalRequest: originalRequest.clone(),\n          request: pluginFilteredRequest.clone()\n        });\n      }\n      throw error;\n    }\n  }\n  /**\n   * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on\n   * the response generated by `this.fetch()`.\n   *\n   * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,\n   * so you do not have to manually call `waitUntil()` on the event.\n   *\n   * @param {Request|string} input The request or URL to fetch and cache.\n   * @return {Promise<Response>}\n   */\n  async fetchAndCachePut(input) {\n    const response = await this.fetch(input);\n    const responseClone = response.clone();\n    void this.waitUntil(this.cachePut(input, responseClone));\n    return response;\n  }\n  /**\n   * Matches a request from the cache (and invokes any applicable plugin\n   * callback methods) using the `cacheName`, `matchOptions`, and `plugins`\n   * defined on the strategy object.\n   *\n   * The following plugin lifecycle methods are invoked when using this method:\n   * - cacheKeyWillByUsed()\n   * - cachedResponseWillByUsed()\n   *\n   * @param {Request|string} key The Request or URL to use as the cache key.\n   * @return {Promise<Response|undefined>} A matching response, if found.\n   */\n  async cacheMatch(key) {\n    const request = toRequest(key);\n    let cachedResponse;\n    const {\n      cacheName,\n      matchOptions\n    } = this._strategy;\n    const effectiveRequest = await this.getCacheKey(request, 'read');\n    const multiMatchOptions = Object.assign(Object.assign({}, matchOptions), {\n      cacheName\n    });\n    cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);\n    if (process.env.NODE_ENV !== 'production') {\n      if (cachedResponse) {\n        logger.debug(`Found a cached response in '${cacheName}'.`);\n      } else {\n        logger.debug(`No cached response found in '${cacheName}'.`);\n      }\n    }\n    for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {\n      cachedResponse = (await callback({\n        cacheName,\n        matchOptions,\n        cachedResponse,\n        request: effectiveRequest,\n        event: this.event\n      })) || undefined;\n    }\n    return cachedResponse;\n  }\n  /**\n   * Puts a request/response pair in the cache (and invokes any applicable\n   * plugin callback methods) using the `cacheName` and `plugins` defined on\n   * the strategy object.\n   *\n   * The following plugin lifecycle methods are invoked when using this method:\n   * - cacheKeyWillByUsed()\n   * - cacheWillUpdate()\n   * - cacheDidUpdate()\n   *\n   * @param {Request|string} key The request or URL to use as the cache key.\n   * @param {Response} response The response to cache.\n   * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response\n   * not be cached, and `true` otherwise.\n   */\n  async cachePut(key, response) {\n    const request = toRequest(key);\n    // Run in the next task to avoid blocking other cache reads.\n    // https://github.com/w3c/ServiceWorker/issues/1397\n    await timeout(0);\n    const effectiveRequest = await this.getCacheKey(request, 'write');\n    if (process.env.NODE_ENV !== 'production') {\n      if (effectiveRequest.method && effectiveRequest.method !== 'GET') {\n        throw new WorkboxError('attempt-to-cache-non-get-request', {\n          url: getFriendlyURL(effectiveRequest.url),\n          method: effectiveRequest.method\n        });\n      }\n      // See https://github.com/GoogleChrome/workbox/issues/2818\n      const vary = response.headers.get('Vary');\n      if (vary) {\n        logger.debug(`The response for ${getFriendlyURL(effectiveRequest.url)} ` + `has a 'Vary: ${vary}' header. ` + `Consider setting the {ignoreVary: true} option on your strategy ` + `to ensure cache matching and deletion works as expected.`);\n      }\n    }\n    if (!response) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error(`Cannot cache non-existent response for ` + `'${getFriendlyURL(effectiveRequest.url)}'.`);\n      }\n      throw new WorkboxError('cache-put-with-no-response', {\n        url: getFriendlyURL(effectiveRequest.url)\n      });\n    }\n    const responseToCache = await this._ensureResponseSafeToCache(response);\n    if (!responseToCache) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' ` + `will not be cached.`, responseToCache);\n      }\n      return false;\n    }\n    const {\n      cacheName,\n      matchOptions\n    } = this._strategy;\n    const cache = await self.caches.open(cacheName);\n    const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');\n    const oldResponse = hasCacheUpdateCallback ? await cacheMatchIgnoreParams(\n    // TODO(philipwalton): the `__WB_REVISION__` param is a precaching\n    // feature. Consider into ways to only add this behavior if using\n    // precaching.\n    cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions) : null;\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Updating the '${cacheName}' cache with a new Response ` + `for ${getFriendlyURL(effectiveRequest.url)}.`);\n    }\n    try {\n      await cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);\n    } catch (error) {\n      if (error instanceof Error) {\n        // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n        if (error.name === 'QuotaExceededError') {\n          await executeQuotaErrorCallbacks();\n        }\n        throw error;\n      }\n    }\n    for (const callback of this.iterateCallbacks('cacheDidUpdate')) {\n      await callback({\n        cacheName,\n        oldResponse,\n        newResponse: responseToCache.clone(),\n        request: effectiveRequest,\n        event: this.event\n      });\n    }\n    return true;\n  }\n  /**\n   * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and\n   * executes any of those callbacks found in sequence. The final `Request`\n   * object returned by the last plugin is treated as the cache key for cache\n   * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have\n   * been registered, the passed request is returned unmodified\n   *\n   * @param {Request} request\n   * @param {string} mode\n   * @return {Promise<Request>}\n   */\n  async getCacheKey(request, mode) {\n    const key = `${request.url} | ${mode}`;\n    if (!this._cacheKeys[key]) {\n      let effectiveRequest = request;\n      for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {\n        effectiveRequest = toRequest(await callback({\n          mode,\n          request: effectiveRequest,\n          event: this.event,\n          // params has a type any can't change right now.\n          params: this.params // eslint-disable-line\n        }));\n      }\n\n      this._cacheKeys[key] = effectiveRequest;\n    }\n    return this._cacheKeys[key];\n  }\n  /**\n   * Returns true if the strategy has at least one plugin with the given\n   * callback.\n   *\n   * @param {string} name The name of the callback to check for.\n   * @return {boolean}\n   */\n  hasCallback(name) {\n    for (const plugin of this._strategy.plugins) {\n      if (name in plugin) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Runs all plugin callbacks matching the given name, in order, passing the\n   * given param object (merged ith the current plugin state) as the only\n   * argument.\n   *\n   * Note: since this method runs all plugins, it's not suitable for cases\n   * where the return value of a callback needs to be applied prior to calling\n   * the next callback. See\n   * {@link workbox-strategies.StrategyHandler#iterateCallbacks}\n   * below for how to handle that case.\n   *\n   * @param {string} name The name of the callback to run within each plugin.\n   * @param {Object} param The object to pass as the first (and only) param\n   *     when executing each callback. This object will be merged with the\n   *     current plugin state prior to callback execution.\n   */\n  async runCallbacks(name, param) {\n    for (const callback of this.iterateCallbacks(name)) {\n      // TODO(philipwalton): not sure why `any` is needed. It seems like\n      // this should work with `as WorkboxPluginCallbackParam[C]`.\n      await callback(param);\n    }\n  }\n  /**\n   * Accepts a callback and returns an iterable of matching plugin callbacks,\n   * where each callback is wrapped with the current handler state (i.e. when\n   * you call each callback, whatever object parameter you pass it will\n   * be merged with the plugin's current state).\n   *\n   * @param {string} name The name fo the callback to run\n   * @return {Array<Function>}\n   */\n  *iterateCallbacks(name) {\n    for (const plugin of this._strategy.plugins) {\n      if (typeof plugin[name] === 'function') {\n        const state = this._pluginStateMap.get(plugin);\n        const statefulCallback = param => {\n          const statefulParam = Object.assign(Object.assign({}, param), {\n            state\n          });\n          // TODO(philipwalton): not sure why `any` is needed. It seems like\n          // this should work with `as WorkboxPluginCallbackParam[C]`.\n          return plugin[name](statefulParam);\n        };\n        yield statefulCallback;\n      }\n    }\n  }\n  /**\n   * Adds a promise to the\n   * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}\n   * of the event event associated with the request being handled (usually a\n   * `FetchEvent`).\n   *\n   * Note: you can await\n   * {@link workbox-strategies.StrategyHandler~doneWaiting}\n   * to know when all added promises have settled.\n   *\n   * @param {Promise} promise A promise to add to the extend lifetime promises\n   *     of the event that triggered the request.\n   */\n  waitUntil(promise) {\n    this._extendLifetimePromises.push(promise);\n    return promise;\n  }\n  /**\n   * Returns a promise that resolves once all promises passed to\n   * {@link workbox-strategies.StrategyHandler~waitUntil}\n   * have settled.\n   *\n   * Note: any work done after `doneWaiting()` settles should be manually\n   * passed to an event's `waitUntil()` method (not this handler's\n   * `waitUntil()` method), otherwise the service worker thread my be killed\n   * prior to your work completing.\n   */\n  async doneWaiting() {\n    let promise;\n    while (promise = this._extendLifetimePromises.shift()) {\n      await promise;\n    }\n  }\n  /**\n   * Stops running the strategy and immediately resolves any pending\n   * `waitUntil()` promises.\n   */\n  destroy() {\n    this._handlerDeferred.resolve(null);\n  }\n  /**\n   * This method will call cacheWillUpdate on the available plugins (or use\n   * status === 200) to determine if the Response is safe and valid to cache.\n   *\n   * @param {Request} options.request\n   * @param {Response} options.response\n   * @return {Promise<Response|undefined>}\n   *\n   * @private\n   */\n  async _ensureResponseSafeToCache(response) {\n    let responseToCache = response;\n    let pluginsUsed = false;\n    for (const callback of this.iterateCallbacks('cacheWillUpdate')) {\n      responseToCache = (await callback({\n        request: this.request,\n        response: responseToCache,\n        event: this.event\n      })) || undefined;\n      pluginsUsed = true;\n      if (!responseToCache) {\n        break;\n      }\n    }\n    if (!pluginsUsed) {\n      if (responseToCache && responseToCache.status !== 200) {\n        responseToCache = undefined;\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        if (responseToCache) {\n          if (responseToCache.status !== 200) {\n            if (responseToCache.status === 0) {\n              logger.warn(`The response for '${this.request.url}' ` + `is an opaque response. The caching strategy that you're ` + `using will not cache opaque responses by default.`);\n            } else {\n              logger.debug(`The response for '${this.request.url}' ` + `returned a status code of '${response.status}' and won't ` + `be cached as a result.`);\n            }\n          }\n        }\n      }\n    }\n    return responseToCache;\n  }\n}\nexport { StrategyHandler };","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from '../_private/logger.js';\nimport { quotaErrorCallbacks } from '../models/quotaErrorCallbacks.js';\nimport '../_version.js';\n/**\n * Runs all of the callback functions, one at a time sequentially, in the order\n * in which they were registered.\n *\n * @memberof workbox-core\n * @private\n */\nasync function executeQuotaErrorCallbacks() {\n  if (process.env.NODE_ENV !== 'production') {\n    logger.log(`About to run ${quotaErrorCallbacks.size} ` + `callbacks to clean up caches.`);\n  }\n  for (const callback of quotaErrorCallbacks) {\n    await callback();\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(callback, 'is complete.');\n    }\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    logger.log('Finished running callbacks.');\n  }\n}\nexport { executeQuotaErrorCallbacks };","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { StrategyHandler } from './StrategyHandler.js';\nimport './_version.js';\n/**\n * An abstract base class that all other strategy classes must extend from:\n *\n * @memberof workbox-strategies\n */\nclass Strategy {\n  /**\n   * Creates a new instance of the strategy and sets all documented option\n   * properties as public instance properties.\n   *\n   * Note: if a custom strategy class extends the base Strategy class and does\n   * not need more than these properties, it does not need to define its own\n   * constructor.\n   *\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] Cache name to store and retrieve\n   * requests. Defaults to the cache names provided by\n   * {@link workbox-core.cacheNames}.\n   * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} [options.fetchOptions] Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n   * `fetch()` requests made by this strategy.\n   * @param {Object} [options.matchOptions] The\n   * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n   * for any `cache.match()` or `cache.put()` calls made by this strategy.\n   */\n  constructor(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    /**\n     * Cache name to store and retrieve\n     * requests. Defaults to the cache names provided by\n     * {@link workbox-core.cacheNames}.\n     *\n     * @type {string}\n     */\n    this.cacheName = cacheNames.getRuntimeName(options.cacheName);\n    /**\n     * The list\n     * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * used by this strategy.\n     *\n     * @type {Array<Object>}\n     */\n    this.plugins = options.plugins || [];\n    /**\n     * Values passed along to the\n     * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\n     * of all fetch() requests made by this strategy.\n     *\n     * @type {Object}\n     */\n    this.fetchOptions = options.fetchOptions;\n    /**\n     * The\n     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\n     *\n     * @type {Object}\n     */\n    this.matchOptions = options.matchOptions;\n  }\n  /**\n   * Perform a request strategy and returns a `Promise` that will resolve with\n   * a `Response`, invoking all relevant plugin callbacks.\n   *\n   * When a strategy instance is registered with a Workbox\n   * {@link workbox-routing.Route}, this method is automatically\n   * called when the route matches.\n   *\n   * Alternatively, this method can be used in a standalone `FetchEvent`\n   * listener by passing it to `event.respondWith()`.\n   *\n   * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n   *     properties listed below.\n   * @param {Request|string} options.request A request to run this strategy for.\n   * @param {ExtendableEvent} options.event The event associated with the\n   *     request.\n   * @param {URL} [options.url]\n   * @param {*} [options.params]\n   */\n  handle(options) {\n    const [responseDone] = this.handleAll(options);\n    return responseDone;\n  }\n  /**\n   * Similar to {@link workbox-strategies.Strategy~handle}, but\n   * instead of just returning a `Promise` that resolves to a `Response` it\n   * it will return an tuple of `[response, done]` promises, where the former\n   * (`response`) is equivalent to what `handle()` returns, and the latter is a\n   * Promise that will resolve once any promises that were added to\n   * `event.waitUntil()` as part of performing the strategy have completed.\n   *\n   * You can await the `done` promise to ensure any extra work performed by\n   * the strategy (usually caching responses) completes successfully.\n   *\n   * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n   *     properties listed below.\n   * @param {Request|string} options.request A request to run this strategy for.\n   * @param {ExtendableEvent} options.event The event associated with the\n   *     request.\n   * @param {URL} [options.url]\n   * @param {*} [options.params]\n   * @return {Array<Promise>} A tuple of [response, done]\n   *     promises that can be used to determine when the response resolves as\n   *     well as when the handler has completed all its work.\n   */\n  handleAll(options) {\n    // Allow for flexible options to be passed.\n    if (options instanceof FetchEvent) {\n      options = {\n        event: options,\n        request: options.request\n      };\n    }\n    const event = options.event;\n    const request = typeof options.request === 'string' ? new Request(options.request) : options.request;\n    const params = 'params' in options ? options.params : undefined;\n    const handler = new StrategyHandler(this, {\n      event,\n      request,\n      params\n    });\n    const responseDone = this._getResponse(handler, request, event);\n    const handlerDone = this._awaitComplete(responseDone, handler, request, event);\n    // Return an array of promises, suitable for use with Promise.all().\n    return [responseDone, handlerDone];\n  }\n  async _getResponse(handler, request, event) {\n    await handler.runCallbacks('handlerWillStart', {\n      event,\n      request\n    });\n    let response = undefined;\n    try {\n      response = await this._handle(request, handler);\n      // The \"official\" Strategy subclasses all throw this error automatically,\n      // but in case a third-party Strategy doesn't, ensure that we have a\n      // consistent failure when there's no response or an error response.\n      if (!response || response.type === 'error') {\n        throw new WorkboxError('no-response', {\n          url: request.url\n        });\n      }\n    } catch (error) {\n      if (error instanceof Error) {\n        for (const callback of handler.iterateCallbacks('handlerDidError')) {\n          response = await callback({\n            error,\n            event,\n            request\n          });\n          if (response) {\n            break;\n          }\n        }\n      }\n      if (!response) {\n        throw error;\n      } else if (process.env.NODE_ENV !== 'production') {\n        logger.log(`While responding to '${getFriendlyURL(request.url)}', ` + `an ${error instanceof Error ? error.toString() : ''} error occurred. Using a fallback response provided by ` + `a handlerDidError plugin.`);\n      }\n    }\n    for (const callback of handler.iterateCallbacks('handlerWillRespond')) {\n      response = await callback({\n        event,\n        request,\n        response\n      });\n    }\n    return response;\n  }\n  async _awaitComplete(responseDone, handler, request, event) {\n    let response;\n    let error;\n    try {\n      response = await responseDone;\n    } catch (error) {\n      // Ignore errors, as response errors should be caught via the `response`\n      // promise above. The `done` promise will only throw for errors in\n      // promises passed to `handler.waitUntil()`.\n    }\n    try {\n      await handler.runCallbacks('handlerDidRespond', {\n        event,\n        request,\n        response\n      });\n      await handler.doneWaiting();\n    } catch (waitUntilError) {\n      if (waitUntilError instanceof Error) {\n        error = waitUntilError;\n      }\n    }\n    await handler.runCallbacks('handlerDidComplete', {\n      event,\n      request,\n      response,\n      error: error\n    });\n    handler.destroy();\n    if (error) {\n      throw error;\n    }\n  }\n}\nexport { Strategy };\n/**\n * Classes extending the `Strategy` based class should implement this method,\n * and leverage the {@link workbox-strategies.StrategyHandler}\n * arg to perform all fetching and cache logic, which will ensure all relevant\n * cache, cache options, fetch options and plugins are used (per the current\n * strategy instance).\n *\n * @name _handle\n * @instance\n * @abstract\n * @function\n * @param {Request} request\n * @param {workbox-strategies.StrategyHandler} handler\n * @return {Promise<Response>}\n *\n * @memberof workbox-strategies.Strategy\n */","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { copyResponse } from 'workbox-core/copyResponse.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from 'workbox-strategies/Strategy.js';\nimport './_version.js';\n/**\n * A {@link workbox-strategies.Strategy} implementation\n * specifically designed to work with\n * {@link workbox-precaching.PrecacheController}\n * to both cache and fetch precached assets.\n *\n * Note: an instance of this class is created automatically when creating a\n * `PrecacheController`; it's generally not necessary to create this yourself.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-precaching\n */\nclass PrecacheStrategy extends Strategy {\n  /**\n   *\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] Cache name to store and retrieve\n   * requests. Defaults to the cache names provided by\n   * {@link workbox-core.cacheNames}.\n   * @param {Array<Object>} [options.plugins] {@link https://developers.google.com/web/tools/workbox/guides/using-plugins|Plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} [options.fetchOptions] Values passed along to the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters|init}\n   * of all fetch() requests made by this strategy.\n   * @param {Object} [options.matchOptions] The\n   * {@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions|CacheQueryOptions}\n   * for any `cache.match()` or `cache.put()` calls made by this strategy.\n   * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n   * get the response from the network if there's a precache miss.\n   */\n  constructor(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    options.cacheName = cacheNames.getPrecacheName(options.cacheName);\n    super(options);\n    this._fallbackToNetwork = options.fallbackToNetwork === false ? false : true;\n    // Redirected responses cannot be used to satisfy a navigation request, so\n    // any redirected response must be \"copied\" rather than cloned, so the new\n    // response doesn't contain the `redirected` flag. See:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n    this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin);\n  }\n  /**\n   * @private\n   * @param {Request|string} request A request to run this strategy for.\n   * @param {workbox-strategies.StrategyHandler} handler The event that\n   *     triggered the request.\n   * @return {Promise<Response>}\n   */\n  async _handle(request, handler) {\n    const response = await handler.cacheMatch(request);\n    if (response) {\n      return response;\n    }\n    // If this is an `install` event for an entry that isn't already cached,\n    // then populate the cache.\n    if (handler.event && handler.event.type === 'install') {\n      return await this._handleInstall(request, handler);\n    }\n    // Getting here means something went wrong. An entry that should have been\n    // precached wasn't found in the cache.\n    return await this._handleFetch(request, handler);\n  }\n  async _handleFetch(request, handler) {\n    let response;\n    const params = handler.params || {};\n    // Fall back to the network if we're configured to do so.\n    if (this._fallbackToNetwork) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.warn(`The precached response for ` + `${getFriendlyURL(request.url)} in ${this.cacheName} was not ` + `found. Falling back to the network.`);\n      }\n      const integrityInManifest = params.integrity;\n      const integrityInRequest = request.integrity;\n      const noIntegrityConflict = !integrityInRequest || integrityInRequest === integrityInManifest;\n      // Do not add integrity if the original request is no-cors\n      // See https://github.com/GoogleChrome/workbox/issues/3096\n      response = await handler.fetch(new Request(request, {\n        integrity: request.mode !== 'no-cors' ? integrityInRequest || integrityInManifest : undefined\n      }));\n      // It's only \"safe\" to repair the cache if we're using SRI to guarantee\n      // that the response matches the precache manifest's expectations,\n      // and there's either a) no integrity property in the incoming request\n      // or b) there is an integrity, and it matches the precache manifest.\n      // See https://github.com/GoogleChrome/workbox/issues/2858\n      // Also if the original request users no-cors we don't use integrity.\n      // See https://github.com/GoogleChrome/workbox/issues/3096\n      if (integrityInManifest && noIntegrityConflict && request.mode !== 'no-cors') {\n        this._useDefaultCacheabilityPluginIfNeeded();\n        const wasCached = await handler.cachePut(request, response.clone());\n        if (process.env.NODE_ENV !== 'production') {\n          if (wasCached) {\n            logger.log(`A response for ${getFriendlyURL(request.url)} ` + `was used to \"repair\" the precache.`);\n          }\n        }\n      }\n    } else {\n      // This shouldn't normally happen, but there are edge cases:\n      // https://github.com/GoogleChrome/workbox/issues/1441\n      throw new WorkboxError('missing-precache-entry', {\n        cacheName: this.cacheName,\n        url: request.url\n      });\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      const cacheKey = params.cacheKey || (await handler.getCacheKey(request, 'read'));\n      // Workbox is going to handle the route.\n      // print the routing details to the console.\n      logger.groupCollapsed(`Precaching is responding to: ` + getFriendlyURL(request.url));\n      logger.log(`Serving the precached url: ${getFriendlyURL(cacheKey instanceof Request ? cacheKey.url : cacheKey)}`);\n      logger.groupCollapsed(`View request details here.`);\n      logger.log(request);\n      logger.groupEnd();\n      logger.groupCollapsed(`View response details here.`);\n      logger.log(response);\n      logger.groupEnd();\n      logger.groupEnd();\n    }\n    return response;\n  }\n  async _handleInstall(request, handler) {\n    this._useDefaultCacheabilityPluginIfNeeded();\n    const response = await handler.fetch(request);\n    // Make sure we defer cachePut() until after we know the response\n    // should be cached; see https://github.com/GoogleChrome/workbox/issues/2737\n    const wasCached = await handler.cachePut(request, response.clone());\n    if (!wasCached) {\n      // Throwing here will lead to the `install` handler failing, which\n      // we want to do if *any* of the responses aren't safe to cache.\n      throw new WorkboxError('bad-precaching-response', {\n        url: request.url,\n        status: response.status\n      });\n    }\n    return response;\n  }\n  /**\n   * This method is complex, as there a number of things to account for:\n   *\n   * The `plugins` array can be set at construction, and/or it might be added to\n   * to at any time before the strategy is used.\n   *\n   * At the time the strategy is used (i.e. during an `install` event), there\n   * needs to be at least one plugin that implements `cacheWillUpdate` in the\n   * array, other than `copyRedirectedCacheableResponsesPlugin`.\n   *\n   * - If this method is called and there are no suitable `cacheWillUpdate`\n   * plugins, we need to add `defaultPrecacheCacheabilityPlugin`.\n   *\n   * - If this method is called and there is exactly one `cacheWillUpdate`, then\n   * we don't have to do anything (this might be a previously added\n   * `defaultPrecacheCacheabilityPlugin`, or it might be a custom plugin).\n   *\n   * - If this method is called and there is more than one `cacheWillUpdate`,\n   * then we need to check if one is `defaultPrecacheCacheabilityPlugin`. If so,\n   * we need to remove it. (This situation is unlikely, but it could happen if\n   * the strategy is used multiple times, the first without a `cacheWillUpdate`,\n   * and then later on after manually adding a custom `cacheWillUpdate`.)\n   *\n   * See https://github.com/GoogleChrome/workbox/issues/2737 for more context.\n   *\n   * @private\n   */\n  _useDefaultCacheabilityPluginIfNeeded() {\n    let defaultPluginIndex = null;\n    let cacheWillUpdatePluginCount = 0;\n    for (const [index, plugin] of this.plugins.entries()) {\n      // Ignore the copy redirected plugin when determining what to do.\n      if (plugin === PrecacheStrategy.copyRedirectedCacheableResponsesPlugin) {\n        continue;\n      }\n      // Save the default plugin's index, in case it needs to be removed.\n      if (plugin === PrecacheStrategy.defaultPrecacheCacheabilityPlugin) {\n        defaultPluginIndex = index;\n      }\n      if (plugin.cacheWillUpdate) {\n        cacheWillUpdatePluginCount++;\n      }\n    }\n    if (cacheWillUpdatePluginCount === 0) {\n      this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin);\n    } else if (cacheWillUpdatePluginCount > 1 && defaultPluginIndex !== null) {\n      // Only remove the default plugin; multiple custom plugins are allowed.\n      this.plugins.splice(defaultPluginIndex, 1);\n    }\n    // Nothing needs to be done if cacheWillUpdatePluginCount is 1\n  }\n}\n\nPrecacheStrategy.defaultPrecacheCacheabilityPlugin = {\n  async cacheWillUpdate(_ref) {\n    let {\n      response\n    } = _ref;\n    if (!response || response.status >= 400) {\n      return null;\n    }\n    return response;\n  }\n};\nPrecacheStrategy.copyRedirectedCacheableResponsesPlugin = {\n  async cacheWillUpdate(_ref2) {\n    let {\n      response\n    } = _ref2;\n    return response.redirected ? await copyResponse(response) : response;\n  }\n};\nexport { PrecacheStrategy };","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { waitUntil } from 'workbox-core/_private/waitUntil.js';\nimport { createCacheKey } from './utils/createCacheKey.js';\nimport { PrecacheInstallReportPlugin } from './utils/PrecacheInstallReportPlugin.js';\nimport { PrecacheCacheKeyPlugin } from './utils/PrecacheCacheKeyPlugin.js';\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\nimport { printInstallDetails } from './utils/printInstallDetails.js';\nimport { PrecacheStrategy } from './PrecacheStrategy.js';\nimport './_version.js';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof workbox-precaching\n */\nclass PrecacheController {\n  /**\n   * Create a new PrecacheController.\n   *\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] The cache to use for precaching.\n   * @param {string} [options.plugins] Plugins to use when precaching as well\n   * as responding to fetch events for precached assets.\n   * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n   * get the response from the network if there's a precache miss.\n   */\n  constructor(_temp) {\n    let {\n      cacheName,\n      plugins = [],\n      fallbackToNetwork = true\n    } = _temp === void 0 ? {} : _temp;\n    this._urlsToCacheKeys = new Map();\n    this._urlsToCacheModes = new Map();\n    this._cacheKeysToIntegrities = new Map();\n    this._strategy = new PrecacheStrategy({\n      cacheName: cacheNames.getPrecacheName(cacheName),\n      plugins: [...plugins, new PrecacheCacheKeyPlugin({\n        precacheController: this\n      })],\n      fallbackToNetwork\n    });\n    // Bind the install and activate methods to the instance.\n    this.install = this.install.bind(this);\n    this.activate = this.activate.bind(this);\n  }\n  /**\n   * @type {workbox-precaching.PrecacheStrategy} The strategy created by this controller and\n   * used to cache assets and respond to fetch events.\n   */\n  get strategy() {\n    return this._strategy;\n  }\n  /**\n   * Adds items to the precache list, removing any duplicates and\n   * stores the files in the\n   * {@link workbox-core.cacheNames|\"precache cache\"} when the service\n   * worker installs.\n   *\n   * This method can be called multiple times.\n   *\n   * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n   */\n  precache(entries) {\n    this.addToCacheList(entries);\n    if (!this._installAndActiveListenersAdded) {\n      self.addEventListener('install', this.install);\n      self.addEventListener('activate', this.activate);\n      this._installAndActiveListenersAdded = true;\n    }\n  }\n  /**\n   * This method will add items to the precache list, removing duplicates\n   * and ensuring the information is valid.\n   *\n   * @param {Array<workbox-precaching.PrecacheController.PrecacheEntry|string>} entries\n   *     Array of entries to precache.\n   */\n  addToCacheList(entries) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isArray(entries, {\n        moduleName: 'workbox-precaching',\n        className: 'PrecacheController',\n        funcName: 'addToCacheList',\n        paramName: 'entries'\n      });\n    }\n    const urlsToWarnAbout = [];\n    for (const entry of entries) {\n      // See https://github.com/GoogleChrome/workbox/issues/2259\n      if (typeof entry === 'string') {\n        urlsToWarnAbout.push(entry);\n      } else if (entry && entry.revision === undefined) {\n        urlsToWarnAbout.push(entry.url);\n      }\n      const {\n        cacheKey,\n        url\n      } = createCacheKey(entry);\n      const cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';\n      if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {\n        throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n          firstEntry: this._urlsToCacheKeys.get(url),\n          secondEntry: cacheKey\n        });\n      }\n      if (typeof entry !== 'string' && entry.integrity) {\n        if (this._cacheKeysToIntegrities.has(cacheKey) && this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n          throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n            url\n          });\n        }\n        this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n      }\n      this._urlsToCacheKeys.set(url, cacheKey);\n      this._urlsToCacheModes.set(url, cacheMode);\n      if (urlsToWarnAbout.length > 0) {\n        const warningMessage = `Workbox is precaching URLs without revision ` + `info: ${urlsToWarnAbout.join(', ')}\\nThis is generally NOT safe. ` + `Learn more at https://bit.ly/wb-precache`;\n        if (process.env.NODE_ENV === 'production') {\n          // Use console directly to display this warning without bloating\n          // bundle sizes by pulling in all of the logger codebase in prod.\n          console.warn(warningMessage);\n        } else {\n          logger.warn(warningMessage);\n        }\n      }\n    }\n  }\n  /**\n   * Precaches new and updated assets. Call this method from the service worker\n   * install event.\n   *\n   * Note: this method calls `event.waitUntil()` for you, so you do not need\n   * to call it yourself in your event handlers.\n   *\n   * @param {ExtendableEvent} event\n   * @return {Promise<workbox-precaching.InstallResult>}\n   */\n  install(event) {\n    // waitUntil returns Promise<any>\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return waitUntil(event, async () => {\n      const installReportPlugin = new PrecacheInstallReportPlugin();\n      this.strategy.plugins.push(installReportPlugin);\n      // Cache entries one at a time.\n      // See https://github.com/GoogleChrome/workbox/issues/2528\n      for (const [url, cacheKey] of this._urlsToCacheKeys) {\n        const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n        const cacheMode = this._urlsToCacheModes.get(url);\n        const request = new Request(url, {\n          integrity,\n          cache: cacheMode,\n          credentials: 'same-origin'\n        });\n        await Promise.all(this.strategy.handleAll({\n          params: {\n            cacheKey\n          },\n          request,\n          event\n        }));\n      }\n      const {\n        updatedURLs,\n        notUpdatedURLs\n      } = installReportPlugin;\n      if (process.env.NODE_ENV !== 'production') {\n        printInstallDetails(updatedURLs, notUpdatedURLs);\n      }\n      return {\n        updatedURLs,\n        notUpdatedURLs\n      };\n    });\n  }\n  /**\n   * Deletes assets that are no longer present in the current precache manifest.\n   * Call this method from the service worker activate event.\n   *\n   * Note: this method calls `event.waitUntil()` for you, so you do not need\n   * to call it yourself in your event handlers.\n   *\n   * @param {ExtendableEvent} event\n   * @return {Promise<workbox-precaching.CleanupResult>}\n   */\n  activate(event) {\n    // waitUntil returns Promise<any>\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return waitUntil(event, async () => {\n      const cache = await self.caches.open(this.strategy.cacheName);\n      const currentlyCachedRequests = await cache.keys();\n      const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n      const deletedURLs = [];\n      for (const request of currentlyCachedRequests) {\n        if (!expectedCacheKeys.has(request.url)) {\n          await cache.delete(request);\n          deletedURLs.push(request.url);\n        }\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        printCleanupDetails(deletedURLs);\n      }\n      return {\n        deletedURLs\n      };\n    });\n  }\n  /**\n   * Returns a mapping of a precached URL to the corresponding cache key, taking\n   * into account the revision information for the URL.\n   *\n   * @return {Map<string, string>} A URL to cache key mapping.\n   */\n  getURLsToCacheKeys() {\n    return this._urlsToCacheKeys;\n  }\n  /**\n   * Returns a list of all the URLs that have been precached by the current\n   * service worker.\n   *\n   * @return {Array<string>} The precached URLs.\n   */\n  getCachedURLs() {\n    return [...this._urlsToCacheKeys.keys()];\n  }\n  /**\n   * Returns the cache key used for storing a given URL. If that URL is\n   * unversioned, like `/index.html', then the cache key will be the original\n   * URL with a search parameter appended to it.\n   *\n   * @param {string} url A URL whose cache key you want to look up.\n   * @return {string} The versioned URL that corresponds to a cache key\n   * for the original URL, or undefined if that URL isn't precached.\n   */\n  getCacheKeyForURL(url) {\n    const urlObject = new URL(url, location.href);\n    return this._urlsToCacheKeys.get(urlObject.href);\n  }\n  /**\n   * @param {string} url A cache key whose SRI you want to look up.\n   * @return {string} The subresource integrity associated with the cache key,\n   * or undefined if it's not set.\n   */\n  getIntegrityForCacheKey(cacheKey) {\n    return this._cacheKeysToIntegrities.get(cacheKey);\n  }\n  /**\n   * This acts as a drop-in replacement for\n   * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n   * with the following differences:\n   *\n   * - It knows what the name of the precache is, and only checks in that cache.\n   * - It allows you to pass in an \"original\" URL without versioning parameters,\n   * and it will automatically look up the correct cache key for the currently\n   * active revision of that URL.\n   *\n   * E.g., `matchPrecache('index.html')` will find the correct precached\n   * response for the currently active service worker, even if the actual cache\n   * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n   *\n   * @param {string|Request} request The key (without revisioning parameters)\n   * to look up in the precache.\n   * @return {Promise<Response|undefined>}\n   */\n  async matchPrecache(request) {\n    const url = request instanceof Request ? request.url : request;\n    const cacheKey = this.getCacheKeyForURL(url);\n    if (cacheKey) {\n      const cache = await self.caches.open(this.strategy.cacheName);\n      return cache.match(cacheKey);\n    }\n    return undefined;\n  }\n  /**\n   * Returns a function that looks up `url` in the precache (taking into\n   * account revision information), and returns the corresponding `Response`.\n   *\n   * @param {string} url The precached URL which will be used to lookup the\n   * `Response`.\n   * @return {workbox-routing~handlerCallback}\n   */\n  createHandlerBoundToURL(url) {\n    const cacheKey = this.getCacheKeyForURL(url);\n    if (!cacheKey) {\n      throw new WorkboxError('non-precached-url', {\n        url\n      });\n    }\n    return options => {\n      options.request = new Request(url);\n      options.params = Object.assign({\n        cacheKey\n      }, options.params);\n      return this.strategy.handle(options);\n    };\n  }\n}\nexport { PrecacheController };","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { PrecacheController } from '../PrecacheController.js';\nimport '../_version.js';\nlet precacheController;\n/**\n * @return {PrecacheController}\n * @private\n */\nexport const getOrCreatePrecacheController = () => {\n  if (!precacheController) {\n    precacheController = new PrecacheController();\n  }\n  return precacheController;\n};","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * The default HTTP method, 'GET', used when there's no specific method\n * configured for a route.\n *\n * @type {string}\n *\n * @private\n */\nexport const defaultMethod = 'GET';\n/**\n * The list of valid HTTP methods associated with requests that could be routed.\n *\n * @type {Array<string>}\n *\n * @private\n */\nexport const validMethods = ['DELETE', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT'];","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport '../_version.js';\n/**\n * @param {function()|Object} handler Either a function, or an object with a\n * 'handle' method.\n * @return {Object} An object with a handle method.\n *\n * @private\n */\nexport const normalizeHandler = handler => {\n  if (handler && typeof handler === 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.hasMethod(handler, 'handle', {\n        moduleName: 'workbox-routing',\n        className: 'Route',\n        funcName: 'constructor',\n        paramName: 'handler'\n      });\n    }\n    return handler;\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(handler, 'function', {\n        moduleName: 'workbox-routing',\n        className: 'Route',\n        funcName: 'constructor',\n        paramName: 'handler'\n      });\n    }\n    return {\n      handle: handler\n    };\n  }\n};","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { defaultMethod, validMethods } from './utils/constants.js';\nimport { normalizeHandler } from './utils/normalizeHandler.js';\nimport './_version.js';\n/**\n * A `Route` consists of a pair of callback functions, \"match\" and \"handler\".\n * The \"match\" callback determine if a route should be used to \"handle\" a\n * request by returning a non-falsy value if it can. The \"handler\" callback\n * is called when there is a match and should return a Promise that resolves\n * to a `Response`.\n *\n * @memberof workbox-routing\n */\nclass Route {\n  /**\n   * Constructor for Route class.\n   *\n   * @param {workbox-routing~matchCallback} match\n   * A callback function that determines whether the route matches a given\n   * `fetch` event by returning a non-falsy value.\n   * @param {workbox-routing~handlerCallback} handler A callback\n   * function that returns a Promise resolving to a Response.\n   * @param {string} [method='GET'] The HTTP method to match the Route\n   * against.\n   */\n  constructor(match, handler, method) {\n    if (method === void 0) {\n      method = defaultMethod;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(match, 'function', {\n        moduleName: 'workbox-routing',\n        className: 'Route',\n        funcName: 'constructor',\n        paramName: 'match'\n      });\n      if (method) {\n        assert.isOneOf(method, validMethods, {\n          paramName: 'method'\n        });\n      }\n    }\n    // These values are referenced directly by Router so cannot be\n    // altered by minificaton.\n    this.handler = normalizeHandler(handler);\n    this.match = match;\n    this.method = method;\n  }\n  /**\n   *\n   * @param {workbox-routing-handlerCallback} handler A callback\n   * function that returns a Promise resolving to a Response\n   */\n  setCatchHandler(handler) {\n    this.catchHandler = normalizeHandler(handler);\n  }\n}\nexport { Route };","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { Route } from './Route.js';\nimport './_version.js';\n/**\n * RegExpRoute makes it easy to create a regular expression based\n * {@link workbox-routing.Route}.\n *\n * For same-origin requests the RegExp only needs to match part of the URL. For\n * requests against third-party servers, you must define a RegExp that matches\n * the start of the URL.\n *\n * @memberof workbox-routing\n * @extends workbox-routing.Route\n */\nclass RegExpRoute extends Route {\n  /**\n   * If the regular expression contains\n   * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},\n   * the captured values will be passed to the\n   * {@link workbox-routing~handlerCallback} `params`\n   * argument.\n   *\n   * @param {RegExp} regExp The regular expression to match against URLs.\n   * @param {workbox-routing~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   * @param {string} [method='GET'] The HTTP method to match the Route\n   * against.\n   */\n  constructor(regExp, handler, method) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(regExp, RegExp, {\n        moduleName: 'workbox-routing',\n        className: 'RegExpRoute',\n        funcName: 'constructor',\n        paramName: 'pattern'\n      });\n    }\n    const match = _ref => {\n      let {\n        url\n      } = _ref;\n      const result = regExp.exec(url.href);\n      // Return immediately if there's no match.\n      if (!result) {\n        return;\n      }\n      // Require that the match start at the first character in the URL string\n      // if it's a cross-origin request.\n      // See https://github.com/GoogleChrome/workbox/issues/281 for the context\n      // behind this behavior.\n      if (url.origin !== location.origin && result.index !== 0) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(`The regular expression '${regExp.toString()}' only partially matched ` + `against the cross-origin URL '${url.toString()}'. RegExpRoute's will only ` + `handle cross-origin requests if they match the entire URL.`);\n        }\n        return;\n      }\n      // If the route matches, but there aren't any capture groups defined, then\n      // this will return [], which is truthy and therefore sufficient to\n      // indicate a match.\n      // If there are capture groups, then it will return their values.\n      return result.slice(1);\n    };\n    super(match, handler, method);\n  }\n}\nexport { RegExpRoute };","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { defaultMethod } from './utils/constants.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { normalizeHandler } from './utils/normalizeHandler.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport './_version.js';\n/**\n * The Router can be used to process a `FetchEvent` using one or more\n * {@link workbox-routing.Route}, responding with a `Response` if\n * a matching route exists.\n *\n * If no route matches a given a request, the Router will use a \"default\"\n * handler if one is defined.\n *\n * Should the matching Route throw an error, the Router will use a \"catch\"\n * handler if one is defined to gracefully deal with issues and respond with a\n * Request.\n *\n * If a request matches multiple routes, the **earliest** registered route will\n * be used to respond to the request.\n *\n * @memberof workbox-routing\n */\nclass Router {\n  /**\n   * Initializes a new Router.\n   */\n  constructor() {\n    this._routes = new Map();\n    this._defaultHandlerMap = new Map();\n  }\n  /**\n   * @return {Map<string, Array<workbox-routing.Route>>} routes A `Map` of HTTP\n   * method name ('GET', etc.) to an array of all the corresponding `Route`\n   * instances that are registered.\n   */\n  get routes() {\n    return this._routes;\n  }\n  /**\n   * Adds a fetch event listener to respond to events when a route matches\n   * the event's request.\n   */\n  addFetchListener() {\n    // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n    self.addEventListener('fetch', event => {\n      const {\n        request\n      } = event;\n      const responsePromise = this.handleRequest({\n        request,\n        event\n      });\n      if (responsePromise) {\n        event.respondWith(responsePromise);\n      }\n    });\n  }\n  /**\n   * Adds a message event listener for URLs to cache from the window.\n   * This is useful to cache resources loaded on the page prior to when the\n   * service worker started controlling it.\n   *\n   * The format of the message data sent from the window should be as follows.\n   * Where the `urlsToCache` array may consist of URL strings or an array of\n   * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n   *\n   * ```\n   * {\n   *   type: 'CACHE_URLS',\n   *   payload: {\n   *     urlsToCache: [\n   *       './script1.js',\n   *       './script2.js',\n   *       ['./script3.js', {mode: 'no-cors'}],\n   *     ],\n   *   },\n   * }\n   * ```\n   */\n  addCacheListener() {\n    // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n    self.addEventListener('message', event => {\n      // event.data is type 'any'\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (event.data && event.data.type === 'CACHE_URLS') {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const {\n          payload\n        } = event.data;\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(`Caching URLs from the window`, payload.urlsToCache);\n        }\n        const requestPromises = Promise.all(payload.urlsToCache.map(entry => {\n          if (typeof entry === 'string') {\n            entry = [entry];\n          }\n          const request = new Request(...entry);\n          return this.handleRequest({\n            request,\n            event\n          });\n          // TODO(philipwalton): TypeScript errors without this typecast for\n          // some reason (probably a bug). The real type here should work but\n          // doesn't: `Array<Promise<Response> | undefined>`.\n        })); // TypeScript\n        event.waitUntil(requestPromises);\n        // If a MessageChannel was used, reply to the message on success.\n        if (event.ports && event.ports[0]) {\n          void requestPromises.then(() => event.ports[0].postMessage(true));\n        }\n      }\n    });\n  }\n  /**\n   * Apply the routing rules to a FetchEvent object to get a Response from an\n   * appropriate Route's handler.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to handle.\n   * @param {ExtendableEvent} options.event The event that triggered the\n   *     request.\n   * @return {Promise<Response>|undefined} A promise is returned if a\n   *     registered route can handle the request. If there is no matching\n   *     route and there's no `defaultHandler`, `undefined` is returned.\n   */\n  handleRequest(_ref) {\n    let {\n      request,\n      event\n    } = _ref;\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'handleRequest',\n        paramName: 'options.request'\n      });\n    }\n    const url = new URL(request.url, location.href);\n    if (!url.protocol.startsWith('http')) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Workbox Router only supports URLs that start with 'http'.`);\n      }\n      return;\n    }\n    const sameOrigin = url.origin === location.origin;\n    const {\n      params,\n      route\n    } = this.findMatchingRoute({\n      event,\n      request,\n      sameOrigin,\n      url\n    });\n    let handler = route && route.handler;\n    const debugMessages = [];\n    if (process.env.NODE_ENV !== 'production') {\n      if (handler) {\n        debugMessages.push([`Found a route to handle this request:`, route]);\n        if (params) {\n          debugMessages.push([`Passing the following params to the route's handler:`, params]);\n        }\n      }\n    }\n    // If we don't have a handler because there was no matching route, then\n    // fall back to defaultHandler if that's defined.\n    const method = request.method;\n    if (!handler && this._defaultHandlerMap.has(method)) {\n      if (process.env.NODE_ENV !== 'production') {\n        debugMessages.push(`Failed to find a matching route. Falling ` + `back to the default handler for ${method}.`);\n      }\n      handler = this._defaultHandlerMap.get(method);\n    }\n    if (!handler) {\n      if (process.env.NODE_ENV !== 'production') {\n        // No handler so Workbox will do nothing. If logs is set of debug\n        // i.e. verbose, we should print out this information.\n        logger.debug(`No route found for: ${getFriendlyURL(url)}`);\n      }\n      return;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      // We have a handler, meaning Workbox is going to handle the route.\n      // print the routing details to the console.\n      logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\n      debugMessages.forEach(msg => {\n        if (Array.isArray(msg)) {\n          logger.log(...msg);\n        } else {\n          logger.log(msg);\n        }\n      });\n      logger.groupEnd();\n    }\n    // Wrap in try and catch in case the handle method throws a synchronous\n    // error. It should still callback to the catch handler.\n    let responsePromise;\n    try {\n      responsePromise = handler.handle({\n        url,\n        request,\n        event,\n        params\n      });\n    } catch (err) {\n      responsePromise = Promise.reject(err);\n    }\n    // Get route's catch handler, if it exists\n    const catchHandler = route && route.catchHandler;\n    if (responsePromise instanceof Promise && (this._catchHandler || catchHandler)) {\n      responsePromise = responsePromise.catch(async err => {\n        // If there's a route catch handler, process that first\n        if (catchHandler) {\n          if (process.env.NODE_ENV !== 'production') {\n            // Still include URL here as it will be async from the console group\n            // and may not make sense without the URL\n            logger.groupCollapsed(`Error thrown when responding to: ` + ` ${getFriendlyURL(url)}. Falling back to route's Catch Handler.`);\n            logger.error(`Error thrown by:`, route);\n            logger.error(err);\n            logger.groupEnd();\n          }\n          try {\n            return await catchHandler.handle({\n              url,\n              request,\n              event,\n              params\n            });\n          } catch (catchErr) {\n            if (catchErr instanceof Error) {\n              err = catchErr;\n            }\n          }\n        }\n        if (this._catchHandler) {\n          if (process.env.NODE_ENV !== 'production') {\n            // Still include URL here as it will be async from the console group\n            // and may not make sense without the URL\n            logger.groupCollapsed(`Error thrown when responding to: ` + ` ${getFriendlyURL(url)}. Falling back to global Catch Handler.`);\n            logger.error(`Error thrown by:`, route);\n            logger.error(err);\n            logger.groupEnd();\n          }\n          return this._catchHandler.handle({\n            url,\n            request,\n            event\n          });\n        }\n        throw err;\n      });\n    }\n    return responsePromise;\n  }\n  /**\n   * Checks a request and URL (and optionally an event) against the list of\n   * registered routes, and if there's a match, returns the corresponding\n   * route along with any params generated by the match.\n   *\n   * @param {Object} options\n   * @param {URL} options.url\n   * @param {boolean} options.sameOrigin The result of comparing `url.origin`\n   *     against the current origin.\n   * @param {Request} options.request The request to match.\n   * @param {Event} options.event The corresponding event.\n   * @return {Object} An object with `route` and `params` properties.\n   *     They are populated if a matching route was found or `undefined`\n   *     otherwise.\n   */\n  findMatchingRoute(_ref2) {\n    let {\n      url,\n      sameOrigin,\n      request,\n      event\n    } = _ref2;\n    const routes = this._routes.get(request.method) || [];\n    for (const route of routes) {\n      let params;\n      // route.match returns type any, not possible to change right now.\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const matchResult = route.match({\n        url,\n        sameOrigin,\n        request,\n        event\n      });\n      if (matchResult) {\n        if (process.env.NODE_ENV !== 'production') {\n          // Warn developers that using an async matchCallback is almost always\n          // not the right thing to do.\n          if (matchResult instanceof Promise) {\n            logger.warn(`While routing ${getFriendlyURL(url)}, an async ` + `matchCallback function was used. Please convert the ` + `following route to use a synchronous matchCallback function:`, route);\n          }\n        }\n        // See https://github.com/GoogleChrome/workbox/issues/2079\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        params = matchResult;\n        if (Array.isArray(params) && params.length === 0) {\n          // Instead of passing an empty array in as params, use undefined.\n          params = undefined;\n        } else if (matchResult.constructor === Object &&\n        // eslint-disable-line\n        Object.keys(matchResult).length === 0) {\n          // Instead of passing an empty object in as params, use undefined.\n          params = undefined;\n        } else if (typeof matchResult === 'boolean') {\n          // For the boolean value true (rather than just something truth-y),\n          // don't set params.\n          // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353\n          params = undefined;\n        }\n        // Return early if have a match.\n        return {\n          route,\n          params\n        };\n      }\n    }\n    // If no match was found above, return and empty object.\n    return {};\n  }\n  /**\n   * Define a default `handler` that's called when no routes explicitly\n   * match the incoming request.\n   *\n   * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.\n   *\n   * Without a default handler, unmatched requests will go against the\n   * network as if there were no service worker present.\n   *\n   * @param {workbox-routing~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   * @param {string} [method='GET'] The HTTP method to associate with this\n   * default handler. Each method has its own default.\n   */\n  setDefaultHandler(handler, method) {\n    if (method === void 0) {\n      method = defaultMethod;\n    }\n    this._defaultHandlerMap.set(method, normalizeHandler(handler));\n  }\n  /**\n   * If a Route throws an error while handling a request, this `handler`\n   * will be called and given a chance to provide a response.\n   *\n   * @param {workbox-routing~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   */\n  setCatchHandler(handler) {\n    this._catchHandler = normalizeHandler(handler);\n  }\n  /**\n   * Registers a route with the router.\n   *\n   * @param {workbox-routing.Route} route The route to register.\n   */\n  registerRoute(route) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(route, 'object', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route'\n      });\n      assert.hasMethod(route, 'match', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route'\n      });\n      assert.isType(route.handler, 'object', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route'\n      });\n      assert.hasMethod(route.handler, 'handle', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route.handler'\n      });\n      assert.isType(route.method, 'string', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route.method'\n      });\n    }\n    if (!this._routes.has(route.method)) {\n      this._routes.set(route.method, []);\n    }\n    // Give precedence to all of the earlier routes by adding this additional\n    // route to the end of the array.\n    this._routes.get(route.method).push(route);\n  }\n  /**\n   * Unregisters a route with the router.\n   *\n   * @param {workbox-routing.Route} route The route to unregister.\n   */\n  unregisterRoute(route) {\n    if (!this._routes.has(route.method)) {\n      throw new WorkboxError('unregister-route-but-not-found-with-method', {\n        method: route.method\n      });\n    }\n    const routeIndex = this._routes.get(route.method).indexOf(route);\n    if (routeIndex > -1) {\n      this._routes.get(route.method).splice(routeIndex, 1);\n    } else {\n      throw new WorkboxError('unregister-route-route-not-registered');\n    }\n  }\n}\nexport { Router };","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { Router } from '../Router.js';\nimport '../_version.js';\nlet defaultRouter;\n/**\n * Creates a new, singleton Router instance if one does not exist. If one\n * does already exist, that instance is returned.\n *\n * @private\n * @return {Router}\n */\nexport const getOrCreateDefaultRouter = () => {\n  if (!defaultRouter) {\n    defaultRouter = new Router();\n    // The helpers that use the default Router assume these listeners exist.\n    defaultRouter.addFetchListener();\n    defaultRouter.addCacheListener();\n  }\n  return defaultRouter;\n};","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Route } from './Route.js';\nimport { RegExpRoute } from './RegExpRoute.js';\nimport { getOrCreateDefaultRouter } from './utils/getOrCreateDefaultRouter.js';\nimport './_version.js';\n/**\n * Easily register a RegExp, string, or function with a caching\n * strategy to a singleton Router instance.\n *\n * This method will generate a Route for you if needed and\n * call {@link workbox-routing.Router#registerRoute}.\n *\n * @param {RegExp|string|workbox-routing.Route~matchCallback|workbox-routing.Route} capture\n * If the capture param is a `Route`, all other arguments will be ignored.\n * @param {workbox-routing~handlerCallback} [handler] A callback\n * function that returns a Promise resulting in a Response. This parameter\n * is required if `capture` is not a `Route` object.\n * @param {string} [method='GET'] The HTTP method to match the Route\n * against.\n * @return {workbox-routing.Route} The generated `Route`.\n *\n * @memberof workbox-routing\n */\nfunction registerRoute(capture, handler, method) {\n  let route;\n  if (typeof capture === 'string') {\n    const captureUrl = new URL(capture, location.href);\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(capture.startsWith('/') || capture.startsWith('http'))) {\n        throw new WorkboxError('invalid-string', {\n          moduleName: 'workbox-routing',\n          funcName: 'registerRoute',\n          paramName: 'capture'\n        });\n      }\n      // We want to check if Express-style wildcards are in the pathname only.\n      // TODO: Remove this log message in v4.\n      const valueToCheck = capture.startsWith('http') ? captureUrl.pathname : capture;\n      // See https://github.com/pillarjs/path-to-regexp#parameters\n      const wildcards = '[*:?+]';\n      if (new RegExp(`${wildcards}`).exec(valueToCheck)) {\n        logger.debug(`The '$capture' parameter contains an Express-style wildcard ` + `character (${wildcards}). Strings are now always interpreted as ` + `exact matches; use a RegExp for partial or wildcard matches.`);\n      }\n    }\n    const matchCallback = _ref => {\n      let {\n        url\n      } = _ref;\n      if (process.env.NODE_ENV !== 'production') {\n        if (url.pathname === captureUrl.pathname && url.origin !== captureUrl.origin) {\n          logger.debug(`${capture} only partially matches the cross-origin URL ` + `${url.toString()}. This route will only handle cross-origin requests ` + `if they match the entire URL.`);\n        }\n      }\n      return url.href === captureUrl.href;\n    };\n    // If `capture` is a string then `handler` and `method` must be present.\n    route = new Route(matchCallback, handler, method);\n  } else if (capture instanceof RegExp) {\n    // If `capture` is a `RegExp` then `handler` and `method` must be present.\n    route = new RegExpRoute(capture, handler, method);\n  } else if (typeof capture === 'function') {\n    // If `capture` is a function then `handler` and `method` must be present.\n    route = new Route(capture, handler, method);\n  } else if (capture instanceof Route) {\n    route = capture;\n  } else {\n    throw new WorkboxError('unsupported-route-type', {\n      moduleName: 'workbox-routing',\n      funcName: 'registerRoute',\n      paramName: 'capture'\n    });\n  }\n  const defaultRouter = getOrCreateDefaultRouter();\n  defaultRouter.registerRoute(route);\n  return route;\n}\nexport { registerRoute };","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { Route } from 'workbox-routing/Route.js';\nimport { generateURLVariations } from './utils/generateURLVariations.js';\nimport './_version.js';\n/**\n * A subclass of {@link workbox-routing.Route} that takes a\n * {@link workbox-precaching.PrecacheController}\n * instance and uses it to match incoming requests and handle fetching\n * responses from the precache.\n *\n * @memberof workbox-precaching\n * @extends workbox-routing.Route\n */\nclass PrecacheRoute extends Route {\n  /**\n   * @param {PrecacheController} precacheController A `PrecacheController`\n   * instance used to both match requests and respond to fetch events.\n   * @param {Object} [options] Options to control how requests are matched\n   * against the list of precached URLs.\n   * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n   * check cache entries for a URLs ending with '/' to see if there is a hit when\n   * appending the `directoryIndex` value.\n   * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/, /^fbclid$/]] An\n   * array of regex's to remove search params when looking for a cache match.\n   * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n   * check the cache for the URL with a `.html` added to the end of the end.\n   * @param {workbox-precaching~urlManipulation} [options.urlManipulation]\n   * This is a function that should take a URL and return an array of\n   * alternative URLs that should be checked for precache matches.\n   */\n  constructor(precacheController, options) {\n    const match = _ref => {\n      let {\n        request\n      } = _ref;\n      const urlsToCacheKeys = precacheController.getURLsToCacheKeys();\n      for (const possibleURL of generateURLVariations(request.url, options)) {\n        const cacheKey = urlsToCacheKeys.get(possibleURL);\n        if (cacheKey) {\n          const integrity = precacheController.getIntegrityForCacheKey(cacheKey);\n          return {\n            cacheKey,\n            integrity\n          };\n        }\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Precaching did not find a match for ` + getFriendlyURL(request.url));\n      }\n      return;\n    };\n    super(match, precacheController.strategy);\n  }\n}\nexport { PrecacheRoute };","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { removeIgnoredSearchParams } from './removeIgnoredSearchParams.js';\nimport '../_version.js';\n/**\n * Generator function that yields possible variations on the original URL to\n * check, one at a time.\n *\n * @param {string} url\n * @param {Object} options\n *\n * @private\n * @memberof workbox-precaching\n */\nexport function generateURLVariations(url, _temp) {\n  let {\n    ignoreURLParametersMatching = [/^utm_/, /^fbclid$/],\n    directoryIndex = 'index.html',\n    cleanURLs = true,\n    urlManipulation\n  } = _temp === void 0 ? {} : _temp;\n  return function* () {\n    const urlObject = new URL(url, location.href);\n    urlObject.hash = '';\n    yield urlObject.href;\n    const urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching);\n    yield urlWithoutIgnoredParams.href;\n    if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {\n      const directoryURL = new URL(urlWithoutIgnoredParams.href);\n      directoryURL.pathname += directoryIndex;\n      yield directoryURL.href;\n    }\n    if (cleanURLs) {\n      const cleanURL = new URL(urlWithoutIgnoredParams.href);\n      cleanURL.pathname += '.html';\n      yield cleanURL.href;\n    }\n    if (urlManipulation) {\n      const additionalURLs = urlManipulation({\n        url: urlObject\n      });\n      for (const urlToAttempt of additionalURLs) {\n        yield urlToAttempt.href;\n      }\n    }\n  }();\n}","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * Removes any URL search parameters that should be ignored.\n *\n * @param {URL} urlObject The original URL.\n * @param {Array<RegExp>} ignoreURLParametersMatching RegExps to test against\n * each search parameter name. Matches mean that the search parameter should be\n * ignored.\n * @return {URL} The URL with any ignored search parameters removed.\n *\n * @private\n * @memberof workbox-precaching\n */\nexport function removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching) {\n  if (ignoreURLParametersMatching === void 0) {\n    ignoreURLParametersMatching = [];\n  }\n  // Convert the iterable into an array at the start of the loop to make sure\n  // deletion doesn't mess up iteration.\n  for (const paramName of [...urlObject.searchParams.keys()]) {\n    if (ignoreURLParametersMatching.some(regExp => regExp.test(paramName))) {\n      urlObject.searchParams.delete(paramName);\n    }\n  }\n  return urlObject;\n}","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a [cache-first](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#cache-first-falling-back-to-network)\n * request strategy.\n *\n * A cache first strategy is useful for assets that have been revisioned,\n * such as URLs like `/styles/example.a8f5f1.css`, since they\n * can be cached for long periods of time.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-strategies\n */\nclass CacheFirst extends Strategy {\n  /**\n   * @private\n   * @param {Request|string} request A request to run this strategy for.\n   * @param {workbox-strategies.StrategyHandler} handler The event that\n   *     triggered the request.\n   * @return {Promise<Response>}\n   */\n  async _handle(request, handler) {\n    const logs = [];\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-strategies',\n        className: this.constructor.name,\n        funcName: 'makeRequest',\n        paramName: 'request'\n      });\n    }\n    let response = await handler.cacheMatch(request);\n    let error = undefined;\n    if (!response) {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(`No response found in the '${this.cacheName}' cache. ` + `Will respond with a network request.`);\n      }\n      try {\n        response = await handler.fetchAndCachePut(request);\n      } catch (err) {\n        if (err instanceof Error) {\n          error = err;\n        }\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        if (response) {\n          logs.push(`Got response from network.`);\n        } else {\n          logs.push(`Unable to get a response from the network.`);\n        }\n      }\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        logs.push(`Found a cached response in the '${this.cacheName}' cache.`);\n      }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n      for (const log of logs) {\n        logger.log(log);\n      }\n      messages.printFinalResponse(response);\n      logger.groupEnd();\n    }\n    if (!response) {\n      throw new WorkboxError('no-response', {\n        url: request.url,\n        error\n      });\n    }\n    return response;\n  }\n}\nexport { CacheFirst };","import IntlMessageFormat from 'intl-messageformat';\nimport { unescape } from 'lodash';\nimport locales from './web_push_locales';\n\nconst MAX_NOTIFICATIONS = 5;\nconst GROUP_TAG = 'tag';\n\nconst notify = options =>\n  self.registration.getNotifications().then(notifications => {\n    if (notifications.length >= MAX_NOTIFICATIONS) { // Reached the maximum number of notifications, proceed with grouping\n      const group = {\n        title: formatMessage('notifications.group', options.data.preferred_locale, { count: notifications.length + 1 }),\n        body: notifications.sort((n1, n2) => n1.timestamp < n2.timestamp).map(notification => notification.title).join('\\n'),\n        badge: '/badge.png',\n        icon: '/android-chrome-192x192.png',\n        tag: GROUP_TAG,\n        data: {\n          url: (new URL('/notifications', self.location)).href,\n          count: notifications.length + 1,\n          preferred_locale: options.data.preferred_locale,\n        },\n      };\n\n      notifications.forEach(notification => notification.close());\n\n      return self.registration.showNotification(group.title, group);\n    } else if (notifications.length === 1 && notifications[0].tag === GROUP_TAG) { // Already grouped, proceed with appending the notification to the group\n      const group = cloneNotification(notifications[0]);\n\n      group.title = formatMessage('notifications.group', options.data.preferred_locale, { count: group.data.count + 1 });\n      group.body  = `${options.title}\\n${group.body}`;\n      group.data  = { ...group.data, count: group.data.count + 1 };\n\n      return self.registration.showNotification(group.title, group);\n    }\n\n    return self.registration.showNotification(options.title, options);\n  });\n\nconst fetchFromApi = (path, method, accessToken) => {\n  const url = (new URL(path, self.location)).href;\n\n  return fetch(url, {\n    headers: {\n      'Authorization': `Bearer ${accessToken}`,\n      'Content-Type': 'application/json',\n    },\n\n    method: method,\n    credentials: 'include',\n  }).then(res => {\n    if (res.ok) {\n      return res;\n    } else {\n      throw new Error(res.status);\n    }\n  }).then(res => res.json());\n};\n\nconst cloneNotification = notification => {\n  const clone = {};\n  let k;\n\n  // Object.assign() does not work with notifications\n  for(k in notification) {\n    clone[k] = notification[k];\n  }\n\n  return clone;\n};\n\nconst formatMessage = (messageId, locale, values = {}) =>\n  (new IntlMessageFormat(locales[locale][messageId], locale)).format(values);\n\nconst htmlToPlainText = html =>\n  unescape(html.replace(/<br\\s*\\/?>/g, '\\n').replace(/<\\/p><p>/g, '\\n\\n').replace(/<[^>]*>/g, ''));\n\nexport const handlePush = (event) => {\n  const { access_token, notification_id, preferred_locale, title, body, icon } = event.data.json();\n\n  // Placeholder until more information can be loaded\n  event.waitUntil(\n    fetchFromApi(`/api/v1/notifications/${notification_id}`, 'get', access_token).then(notification => {\n      const options = {};\n\n      options.title     = formatMessage(`notification.${notification.type}`, preferred_locale, { name: notification.account.display_name.length > 0 ? notification.account.display_name : notification.account.username });\n      options.body      = notification.status && htmlToPlainText(notification.status.content);\n      options.icon      = notification.account.avatar_static;\n      options.timestamp = notification.created_at && new Date(notification.created_at);\n      options.tag       = notification.id;\n      options.badge     = '/badge.png';\n      options.image     = notification.status && notification.status.media_attachments.length > 0 && notification.status.media_attachments[0].preview_url || undefined;\n      options.data      = { access_token, preferred_locale, id: notification.status ? notification.status.id : notification.account.id };\n\n      if (notification.status) {\n        options.data.url = `/@${notification.status.account.acct}/${notification.status.id}`;\n      } else {\n        options.data.url = `/@${notification.account.acct}`;\n      }\n\n      if (notification.status && notification.status.spoiler_text || notification.status.sensitive) {\n        options.data.hiddenBody  = htmlToPlainText(notification.status.content);\n        options.data.hiddenImage = notification.status.media_attachments.length > 0 && notification.status.media_attachments[0].preview_url;\n\n        if (notification.status.spoiler_text) {\n          options.body    = notification.status.spoiler_text;\n        }\n\n        options.image   = undefined;\n        options.actions = [actionExpand(preferred_locale)];\n      } else if (['mention', 'status'].includes(notification.type)) {\n        options.actions = [actionReblog(preferred_locale), actionFavourite(preferred_locale)];\n      }\n\n      return notify(options);\n    }).catch(() => {\n      return notify({\n        title,\n        body,\n        icon,\n        tag: notification_id,\n        timestamp: new Date(),\n        badge: '/badge.png',\n        data: { access_token, preferred_locale, url: '/notifications' },\n      });\n    }),\n  );\n};\n\nconst actionExpand = preferred_locale => ({\n  action: 'expand',\n  icon: '/web-push-icon_expand.png',\n  title: formatMessage('status.show_more', preferred_locale),\n});\n\nconst actionReblog = preferred_locale => ({\n  action: 'reblog',\n  icon: '/web-push-icon_reblog.png',\n  title: formatMessage('status.reblog', preferred_locale),\n});\n\nconst actionFavourite = preferred_locale => ({\n  action: 'favourite',\n  icon: '/web-push-icon_favourite.png',\n  title: formatMessage('status.favourite', preferred_locale),\n});\n\nconst findBestClient = clients => {\n  const focusedClient = clients.find(client => client.focused);\n  const visibleClient = clients.find(client => client.visibilityState === 'visible');\n\n  return focusedClient || visibleClient || clients[0];\n};\n\nconst expandNotification = notification => {\n  const newNotification = cloneNotification(notification);\n\n  newNotification.body    = newNotification.data.hiddenBody;\n  newNotification.image   = newNotification.data.hiddenImage;\n  newNotification.actions = [actionReblog(notification.data.preferred_locale), actionFavourite(notification.data.preferred_locale)];\n\n  return self.registration.showNotification(newNotification.title, newNotification);\n};\n\nconst removeActionFromNotification = (notification, action) => {\n  const newNotification = cloneNotification(notification);\n\n  newNotification.actions = newNotification.actions.filter(item => item.action !== action);\n\n  return self.registration.showNotification(newNotification.title, newNotification);\n};\n\nconst openUrl = url =>\n  self.clients.matchAll({ type: 'window' }).then(clientList => {\n    if (clientList.length !== 0 && 'navigate' in clientList[0]) { // Chrome 42-48 does not support navigate\n      const client = findBestClient(clientList);\n\n      return client.navigate(url).then(client => client.focus());\n    }\n\n    return self.clients.openWindow(url);\n  });\n\nexport const handleNotificationClick = (event) => {\n  const reactToNotificationClick = new Promise((resolve, reject) => {\n    if (event.action) {\n      if (event.action === 'expand') {\n        resolve(expandNotification(event.notification));\n      } else if (event.action === 'reblog') {\n        const { data } = event.notification;\n        resolve(fetchFromApi(`/api/v1/statuses/${data.id}/reblog`, 'post', data.access_token).then(() => removeActionFromNotification(event.notification, 'reblog')));\n      } else if (event.action === 'favourite') {\n        const { data } = event.notification;\n        resolve(fetchFromApi(`/api/v1/statuses/${data.id}/favourite`, 'post', data.access_token).then(() => removeActionFromNotification(event.notification, 'favourite')));\n      } else {\n        reject(`Unknown action: ${event.action}`);\n      }\n    } else {\n      event.notification.close();\n      resolve(openUrl(event.notification.data.url));\n    }\n  });\n\n  event.waitUntil(reactToNotificationClick);\n};\n","import { ExpirationPlugin } from 'workbox-expiration';\nimport { precacheAndRoute } from 'workbox-precaching';\nimport { registerRoute } from 'workbox-routing';\nimport { CacheFirst } from 'workbox-strategies';\nimport { handleNotificationClick, handlePush } from './web_push_notifications';\n\nconst CACHE_NAME_PREFIX = 'mastodon-';\n\nfunction openWebCache() {\n  return caches.open(`${CACHE_NAME_PREFIX}web`);\n}\n\nfunction fetchRoot() {\n  return fetch('/', { credentials: 'include', redirect: 'manual' });\n}\n\nprecacheAndRoute(self.__WB_MANIFEST);\n\nregisterRoute(\n  /locale_.*\\.js$/,\n  new CacheFirst({\n    cacheName: `${CACHE_NAME_PREFIX}locales`,\n    plugins: [\n      new ExpirationPlugin({\n        maxAgeSeconds: 30 * 24 * 60 * 60, // 1 month\n        maxEntries: 5,\n      }),\n    ],\n  }),\n);\n\nregisterRoute(\n  ({ request }) => request.destination === 'font',\n  new CacheFirst({\n    cacheName: `${CACHE_NAME_PREFIX}fonts`,\n    plugins: [\n      new ExpirationPlugin({\n        maxAgeSeconds: 30 * 24 * 60 * 60, // 1 month\n        maxEntries: 5,\n      }),\n    ],\n  }),\n);\n\nregisterRoute(\n  ({ request }) => request.destination === 'image',\n  new CacheFirst({\n    cacheName: `m${CACHE_NAME_PREFIX}media`,\n    plugins: [\n      new ExpirationPlugin({\n        maxAgeSeconds: 7 * 24 * 60 * 60, // 1 week\n        maxEntries: 256,\n      }),\n    ],\n  }),\n);\n\n// Cause a new version of a registered Service Worker to replace an existing one\n// that is already installed, and replace the currently active worker on open pages.\nself.addEventListener('install', function(event) {\n  event.waitUntil(Promise.all([openWebCache(), fetchRoot()]).then(([cache, root]) => cache.put('/', root)));\n});\n\nself.addEventListener('activate', function(event) {\n  event.waitUntil(self.clients.claim());\n});\n\nself.addEventListener('fetch', function(event) {\n  const url = new URL(event.request.url);\n\n  if (url.pathname === '/auth/sign_out') {\n    const asyncResponse = fetch(event.request);\n    const asyncCache = openWebCache();\n\n    event.respondWith(asyncResponse.then(response => {\n      if (response.ok || response.type === 'opaqueredirect') {\n        return Promise.all([\n          asyncCache.then(cache => cache.delete('/')),\n          indexedDB.deleteDatabase('mastodon'),\n        ]).then(() => response);\n      }\n\n      return response;\n    }));\n  }\n});\n\nself.addEventListener('push', handlePush);\nself.addEventListener('notificationclick', handleNotificationClick);\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { addRoute } from './addRoute.js';\nimport { precache } from './precache.js';\nimport './_version.js';\n/**\n * This method will add entries to the precache list and add a route to\n * respond to fetch events.\n *\n * This is a convenience method that will call\n * {@link workbox-precaching.precache} and\n * {@link workbox-precaching.addRoute} in a single call.\n *\n * @param {Array<Object|string>} entries Array of entries to precache.\n * @param {Object} [options] See the\n * {@link workbox-precaching.PrecacheRoute} options.\n *\n * @memberof workbox-precaching\n */\nfunction precacheAndRoute(entries, options) {\n  precache(entries);\n  addRoute(options);\n}\nexport { precacheAndRoute };","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { getOrCreatePrecacheController } from './utils/getOrCreatePrecacheController.js';\nimport './_version.js';\n/**\n * Adds items to the precache list, removing any duplicates and\n * stores the files in the\n * {@link workbox-core.cacheNames|\"precache cache\"} when the service\n * worker installs.\n *\n * This method can be called multiple times.\n *\n * Please note: This method **will not** serve any of the cached files for you.\n * It only precaches files. To respond to a network request you call\n * {@link workbox-precaching.addRoute}.\n *\n * If you have a single array of files to precache, you can just call\n * {@link workbox-precaching.precacheAndRoute}.\n *\n * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n *\n * @memberof workbox-precaching\n */\nfunction precache(entries) {\n  const precacheController = getOrCreatePrecacheController();\n  precacheController.precache(entries);\n}\nexport { precache };","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { registerRoute } from 'workbox-routing/registerRoute.js';\nimport { getOrCreatePrecacheController } from './utils/getOrCreatePrecacheController.js';\nimport { PrecacheRoute } from './PrecacheRoute.js';\nimport './_version.js';\n/**\n * Add a `fetch` listener to the service worker that will\n * respond to\n * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n * with precached assets.\n *\n * Requests for assets that aren't precached, the `FetchEvent` will not be\n * responded to, allowing the event to fall through to other `fetch` event\n * listeners.\n *\n * @param {Object} [options] See the {@link workbox-precaching.PrecacheRoute}\n * options.\n *\n * @memberof workbox-precaching\n */\nfunction addRoute(options) {\n  const precacheController = getOrCreatePrecacheController();\n  const precacheRoute = new PrecacheRoute(precacheController, options);\n  registerRoute(precacheRoute);\n}\nexport { addRoute };"]}